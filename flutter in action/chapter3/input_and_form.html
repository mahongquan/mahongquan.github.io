
<!DOCTYPE html>

<html lang="zh-cn">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3.7 输入框及表单 &#8212; flutter in action 1.0 documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="id1">
<h1>3.7 输入框及表单<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>Material组件库中提供了输入框组件<code class="docutils literal notranslate"><span class="pre">TextField</span></code>和表单组件<code class="docutils literal notranslate"><span class="pre">Form</span></code>。下面我们分别介绍一下。</p>
<div class="section" id="textfield">
<h2>3.7.1 TextField<a class="headerlink" href="#textfield" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">TextField</span></code>用于文本输入，它提供了很多属性，我们先简单介绍一下主要属性的作用，然后通过几个示例来演示一下关键属性的用法。</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span> <span class="n">TextField</span><span class="p">({</span>
  <span class="p">...</span>
  <span class="n">TextEditingController</span> <span class="n">controller</span><span class="p">,</span> 
  <span class="n">FocusNode</span> <span class="n">focusNode</span><span class="p">,</span>
  <span class="n">InputDecoration</span> <span class="n">decoration</span> <span class="o">=</span> <span class="kd">const</span> <span class="n">InputDecoration</span><span class="p">(),</span>
  <span class="n">TextInputType</span> <span class="n">keyboardType</span><span class="p">,</span>
  <span class="n">TextInputAction</span> <span class="n">textInputAction</span><span class="p">,</span>
  <span class="n">TextStyle</span> <span class="n">style</span><span class="p">,</span>
  <span class="n">TextAlign</span> <span class="n">textAlign</span> <span class="o">=</span> <span class="n">TextAlign</span><span class="p">.</span><span class="n">start</span><span class="p">,</span>
  <span class="kt">bool</span> <span class="n">autofocus</span> <span class="o">=</span> <span class="kc">false</span><span class="p">,</span>
  <span class="kt">bool</span> <span class="n">obscureText</span> <span class="o">=</span> <span class="kc">false</span><span class="p">,</span>
  <span class="kt">int</span> <span class="n">maxLines</span> <span class="o">=</span> <span class="m">1</span><span class="p">,</span>
  <span class="kt">int</span> <span class="n">maxLength</span><span class="p">,</span>
  <span class="kt">bool</span> <span class="n">maxLengthEnforced</span> <span class="o">=</span> <span class="kc">true</span><span class="p">,</span>
  <span class="n">ValueChanged</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="n">onChanged</span><span class="p">,</span>
  <span class="n">VoidCallback</span> <span class="n">onEditingComplete</span><span class="p">,</span>
  <span class="n">ValueChanged</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="n">onSubmitted</span><span class="p">,</span>
  <span class="n">List</span><span class="o">&lt;</span><span class="n">TextInputFormatter</span><span class="o">&gt;</span> <span class="n">inputFormatters</span><span class="p">,</span>
  <span class="kt">bool</span> <span class="n">enabled</span><span class="p">,</span>
  <span class="k">this</span><span class="p">.</span><span class="n">cursorWidth</span> <span class="o">=</span> <span class="m">2.0</span><span class="p">,</span>
  <span class="k">this</span><span class="p">.</span><span class="n">cursorRadius</span><span class="p">,</span>
  <span class="k">this</span><span class="p">.</span><span class="n">cursorColor</span><span class="p">,</span>
  <span class="p">...</span>
<span class="p">})</span>
</pre></div>
</div>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">controller</span></code>：编辑框的控制器，通过它可以设置/获取编辑框的内容、选择编辑内容、监听编辑文本改变事件。大多数情况下我们都需要显式提供一个<code class="docutils literal notranslate"><span class="pre">controller</span></code>来与文本框交互。如果没有提供<code class="docutils literal notranslate"><span class="pre">controller</span></code>，则<code class="docutils literal notranslate"><span class="pre">TextField</span></code>内部会自动创建一个。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">focusNode</span></code>：用于控制<code class="docutils literal notranslate"><span class="pre">TextField</span></code>是否占有当前键盘的输入焦点。它是我们和键盘交互的一个句柄（handle）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">InputDecoration</span></code>：用于控制<code class="docutils literal notranslate"><span class="pre">TextField</span></code>的外观显示，如提示文本、背景颜色、边框等。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">keyboardType</span></code>：用于设置该输入框默认的键盘输入类型，取值如下：</p>
<p>| TextInputType枚举值 | 含义                                                |
| ——————- | ————————————————— |
| text                | 文本输入键盘                                        |
| multiline           | 多行文本，需和maxLines配合使用(设为null或大于1)     |
| number              | 数字；会弹出数字键盘                                |
| phone               | 优化后的电话号码输入键盘；会弹出数字键盘并显示“* #” |
| datetime            | 优化后的日期输入键盘；Android上会显示“: -”          |
| emailAddress        | 优化后的电子邮件地址；会显示“&#64; .”                   |
| url                 | 优化后的url输入键盘； 会显示“/ .”                   |</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">textInputAction</span></code>：键盘动作按钮图标(即回车键位图标)，它是一个枚举值，有多个可选值，全部的取值列表读者可以查看API文档，下面是当值为<code class="docutils literal notranslate"><span class="pre">TextInputAction.search</span></code>时，原生Android系统下键盘样式如图3-24所示：</p>
<p><img alt="图3-24" src="../_images/3-24.png" /></p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">style</span></code>：正在编辑的文本样式。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">textAlign</span></code>: 输入框内编辑文本在水平方向的对齐方式。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">autofocus</span></code>: 是否自动获取焦点。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">obscureText</span></code>：是否隐藏正在编辑的文本，如用于输入密码的场景等，文本内容会用“•”替换。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">maxLines</span></code>：输入框的最大行数，默认为1；如果为<code class="docutils literal notranslate"><span class="pre">null</span></code>，则无行数限制。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">maxLength</span></code>和<code class="docutils literal notranslate"><span class="pre">maxLengthEnforced</span></code> ：<code class="docutils literal notranslate"><span class="pre">maxLength</span></code>代表输入框文本的最大长度，设置后输入框右下角会显示输入的文本计数。<code class="docutils literal notranslate"><span class="pre">maxLengthEnforced</span></code>决定当输入文本长度超过<code class="docutils literal notranslate"><span class="pre">maxLength</span></code>时是否阻止输入，为<code class="docutils literal notranslate"><span class="pre">true</span></code>时会阻止输入，为<code class="docutils literal notranslate"><span class="pre">false</span></code>时不会阻止输入但输入框会变红。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">onChange</span></code>：输入框内容改变时的回调函数；注：内容改变事件也可以通过<code class="docutils literal notranslate"><span class="pre">controller</span></code>来监听。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">onEditingComplete</span></code>和<code class="docutils literal notranslate"><span class="pre">onSubmitted</span></code>：这两个回调都是在输入框输入完成时触发，比如按了键盘的完成键（对号图标）或搜索键（🔍图标）。不同的是两个回调签名不同，<code class="docutils literal notranslate"><span class="pre">onSubmitted</span></code>回调是<code class="docutils literal notranslate"><span class="pre">ValueChanged&lt;String&gt;</span></code>类型，它接收当前输入内容做为参数，而<code class="docutils literal notranslate"><span class="pre">onEditingComplete</span></code>不接收参数。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">inputFormatters</span></code>：用于指定输入格式；当用户输入内容改变时，会根据指定的格式来校验。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">enable</span></code>：如果为<code class="docutils literal notranslate"><span class="pre">false</span></code>，则输入框会被禁用，禁用状态不接收输入和事件，同时显示禁用态样式（在其<code class="docutils literal notranslate"><span class="pre">decoration</span></code>中定义）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cursorWidth</span></code>、<code class="docutils literal notranslate"><span class="pre">cursorRadius</span></code>和<code class="docutils literal notranslate"><span class="pre">cursorColor</span></code>：这三个属性是用于自定义输入框光标宽度、圆角和颜色的。</p></li>
</ul>
<div class="section" id="id2">
<h3>示例：登录输入框<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id3">
<h4>布局<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="n">Column</span><span class="p">(</span>
        <span class="nl">children:</span> <span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">[</span>
          <span class="n">TextField</span><span class="p">(</span>
            <span class="nl">autofocus:</span> <span class="kc">true</span><span class="p">,</span>
            <span class="nl">decoration:</span> <span class="n">InputDecoration</span><span class="p">(</span>
                <span class="nl">labelText:</span> <span class="s2">&quot;用户名&quot;</span><span class="p">,</span>
                <span class="nl">hintText:</span> <span class="s2">&quot;用户名或邮箱&quot;</span><span class="p">,</span>
                <span class="nl">prefixIcon:</span> <span class="n">Icon</span><span class="p">(</span><span class="n">Icons</span><span class="p">.</span><span class="n">person</span><span class="p">)</span>
            <span class="p">),</span>
          <span class="p">),</span>
          <span class="n">TextField</span><span class="p">(</span>
            <span class="nl">decoration:</span> <span class="n">InputDecoration</span><span class="p">(</span>
                <span class="nl">labelText:</span> <span class="s2">&quot;密码&quot;</span><span class="p">,</span>
                <span class="nl">hintText:</span> <span class="s2">&quot;您的登录密码&quot;</span><span class="p">,</span>
                <span class="nl">prefixIcon:</span> <span class="n">Icon</span><span class="p">(</span><span class="n">Icons</span><span class="p">.</span><span class="n">lock</span><span class="p">)</span>
            <span class="p">),</span>
            <span class="nl">obscureText:</span> <span class="kc">true</span><span class="p">,</span>
          <span class="p">),</span>
        <span class="p">],</span>
<span class="p">);</span>
</pre></div>
</div>
<p>运行后，效果如图3-25所示：</p>
<p><img alt="图3-25" src="../_images/3-25.png" /></p>
</div>
<div class="section" id="id4">
<h4>获取输入内容<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>获取输入内容有两种方式：</p>
<ol class="simple">
<li><p>定义两个变量，用于保存用户名和密码，然后在<code class="docutils literal notranslate"><span class="pre">onChange</span></code>触发时，各自保存一下输入内容。</p></li>
<li><p>通过<code class="docutils literal notranslate"><span class="pre">controller</span></code>直接获取。</p></li>
</ol>
<p>第一种方式比较简单，不在举例，我们来重点看一下第二种方式，我们以用户名输入框举例：</p>
<p>定义一个<code class="docutils literal notranslate"><span class="pre">controller</span></code>：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="c1">//定义一个controller</span>
<span class="n">TextEditingController</span> <span class="n">_unameController</span> <span class="o">=</span> <span class="n">TextEditingController</span><span class="p">();</span>
</pre></div>
</div>
<p>然后设置输入框controller：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="n">TextField</span><span class="p">(</span>
    <span class="nl">autofocus:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="nl">controller:</span> <span class="n">_unameController</span><span class="p">,</span> <span class="c1">//设置controller</span>
    <span class="p">...</span>
<span class="p">)</span>
</pre></div>
</div>
<p>通过controller获取输入框内容</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="n">print</span><span class="p">(</span><span class="n">_unameController</span><span class="p">.</span><span class="n">text</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h4>监听文本变化<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>监听文本变化也有两种方式：</p>
<ol>
<li><p>设置<code class="docutils literal notranslate"><span class="pre">onChange</span></code>回调，如：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="n">TextField</span><span class="p">(</span>
    <span class="nl">autofocus:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="nl">onChanged:</span> <span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">print</span><span class="p">(</span><span class="s2">&quot;onChange: </span><span class="si">$</span><span class="n">v</span><span class="s2">&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>通过<code class="docutils literal notranslate"><span class="pre">controller</span></code>监听，如：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span>@override
void initState() {
  //监听输入改变  
  _unameController.addListener((){
    print(_unameController.text);
  });
}
</pre></div>
</div>
</li>
</ol>
<p>两种方式相比，<code class="docutils literal notranslate"><span class="pre">onChanged</span></code>是专门用于监听文本变化，而<code class="docutils literal notranslate"><span class="pre">controller</span></code>的功能却多一些，除了能监听文本变化外，它还可以设置默认值、选择文本，下面我们看一个例子：</p>
<p>创建一个<code class="docutils literal notranslate"><span class="pre">controller</span></code>:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="n">TextEditingController</span> <span class="n">_selectionController</span> <span class="o">=</span>  <span class="n">TextEditingController</span><span class="p">();</span>
</pre></div>
</div>
<p>设置默认值，并从第三个字符开始选中后面的字符</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="n">_selectionController</span><span class="p">.</span><span class="n">text</span><span class="o">=</span><span class="s2">&quot;hello world!&quot;</span><span class="p">;</span>
<span class="n">_selectionController</span><span class="p">.</span><span class="n">selection</span><span class="o">=</span><span class="n">TextSelection</span><span class="p">(</span>
    <span class="nl">baseOffset:</span> <span class="m">2</span><span class="p">,</span>
    <span class="nl">extentOffset:</span> <span class="n">_selectionController</span><span class="p">.</span><span class="n">text</span><span class="p">.</span><span class="n">length</span>
<span class="p">);</span>
</pre></div>
</div>
<p>设置<code class="docutils literal notranslate"><span class="pre">controlle</span></code>r:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="n">TextField</span><span class="p">(</span>
  <span class="nl">controller:</span> <span class="n">_selectionController</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>运行效果如图3-26所示：</p>
<p><img alt="图3-26" src="../_images/3-26.png" /></p>
</div>
<div class="section" id="id6">
<h4>控制焦点<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<p>焦点可以通过<code class="docutils literal notranslate"><span class="pre">FocusNode</span></code>和<code class="docutils literal notranslate"><span class="pre">FocusScopeNode</span></code>来控制，默认情况下，焦点由<code class="docutils literal notranslate"><span class="pre">FocusScope</span></code>来管理，它代表焦点控制范围，可以在这个范围内可以通过<code class="docutils literal notranslate"><span class="pre">FocusScopeNode</span></code>在输入框之间移动焦点、设置默认焦点等。我们可以通过<code class="docutils literal notranslate"><span class="pre">FocusScope.of(context)</span></code> 来获取Widget树中默认的<code class="docutils literal notranslate"><span class="pre">FocusScopeNode</span></code>。下面看一个示例，在此示例中创建两个<code class="docutils literal notranslate"><span class="pre">TextField</span></code>，第一个自动获取焦点，然后创建两个按钮：</p>
<ul class="simple">
<li><p>点击第一个按钮可以将焦点从第一个<code class="docutils literal notranslate"><span class="pre">TextField</span></code>挪到第二个<code class="docutils literal notranslate"><span class="pre">TextField</span></code>。</p></li>
<li><p>点击第二个按钮可以关闭键盘。</p></li>
</ul>
<p>我们要实现的效果如图3-27所示：</p>
<p><img alt="图3-27" src="../_images/3-27.png" /></p>
<p>代码如下：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span>class FocusTestRoute extends StatefulWidget {
  @override
  _FocusTestRouteState createState() =&gt; new _FocusTestRouteState();
}

class _FocusTestRouteState extends State&lt;FocusTestRoute&gt; {
  FocusNode focusNode1 = new FocusNode();
  FocusNode focusNode2 = new FocusNode();
  FocusScopeNode focusScopeNode;

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: EdgeInsets.all(16.0),
      child: Column(
        children: &lt;Widget&gt;[
          TextField(
            autofocus: true, 
            focusNode: focusNode1,//关联focusNode1
            decoration: InputDecoration(
                labelText: &quot;input1&quot;
            ),
          ),
          TextField(
            focusNode: focusNode2,//关联focusNode2
            decoration: InputDecoration(
                labelText: &quot;input2&quot;
            ),
          ),
          Builder(builder: (ctx) {
            return Column(
              children: &lt;Widget&gt;[
                RaisedButton(
                  child: Text(&quot;移动焦点&quot;),
                  onPressed: () {
                    //将焦点从第一个TextField移到第二个TextField
                    // 这是一种写法 FocusScope.of(context).requestFocus(focusNode2);
                    // 这是第二种写法
                    if(null == focusScopeNode){
                      focusScopeNode = FocusScope.of(context);
                    }
                    focusScopeNode.requestFocus(focusNode2);
                  },
                ),
                RaisedButton(
                  child: Text(&quot;隐藏键盘&quot;),
                  onPressed: () {
                    // 当所有编辑框都失去焦点时键盘就会收起  
                    focusNode1.unfocus();
                    focusNode2.unfocus();
                  },
                ),
              ],
            );
          },
          ),
        ],
      ),
    );
  }

}
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">FocusNode</span></code>和<code class="docutils literal notranslate"><span class="pre">FocusScopeNode</span></code>还有一些其它的方法，详情可以查看API文档。</p>
</div>
<div class="section" id="id7">
<h4>监听焦点状态改变事件<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">FocusNode</span></code>继承自<code class="docutils literal notranslate"><span class="pre">ChangeNotifier</span></code>，通过<code class="docutils literal notranslate"><span class="pre">FocusNode</span></code>可以监听焦点的改变事件，如：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="c1">// 创建 focusNode   </span>
<span class="n">FocusNode</span> <span class="n">focusNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FocusNode</span><span class="p">();</span>
<span class="p">...</span>
<span class="c1">// focusNode绑定输入框   </span>
<span class="n">TextField</span><span class="p">(</span><span class="nl">focusNode:</span> <span class="n">focusNode</span><span class="p">);</span>
<span class="p">...</span>
<span class="c1">// 监听焦点变化    </span>
<span class="n">focusNode</span><span class="p">.</span><span class="n">addListener</span><span class="p">((){</span>
   <span class="n">print</span><span class="p">(</span><span class="n">focusNode</span><span class="p">.</span><span class="n">hasFocus</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
</div>
<p>获得焦点时<code class="docutils literal notranslate"><span class="pre">focusNode.hasFocus</span></code>值为<code class="docutils literal notranslate"><span class="pre">true</span></code>，失去焦点时为<code class="docutils literal notranslate"><span class="pre">false</span></code>。</p>
</div>
<div class="section" id="id8">
<h4>自定义样式<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<p>虽然我们可以通过<code class="docutils literal notranslate"><span class="pre">decoration</span></code>属性来定义输入框样式，下面以自定义输入框下划线颜色为例来介绍一下：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="n">TextField</span><span class="p">(</span>
  <span class="nl">decoration:</span> <span class="n">InputDecoration</span><span class="p">(</span>
    <span class="nl">labelText:</span> <span class="s2">&quot;请输入用户名&quot;</span><span class="p">,</span>
    <span class="nl">prefixIcon:</span> <span class="n">Icon</span><span class="p">(</span><span class="n">Icons</span><span class="p">.</span><span class="n">person</span><span class="p">),</span>
    <span class="c1">// 未获得焦点下划线设为灰色</span>
    <span class="nl">enabledBorder:</span> <span class="n">UnderlineInputBorder</span><span class="p">(</span>
      <span class="nl">borderSide:</span> <span class="n">BorderSide</span><span class="p">(</span><span class="nl">color:</span> <span class="n">Colors</span><span class="p">.</span><span class="n">grey</span><span class="p">),</span>
    <span class="p">),</span>
    <span class="c1">//获得焦点下划线设为蓝色</span>
    <span class="nl">focusedBorder:</span> <span class="n">UnderlineInputBorder</span><span class="p">(</span>
      <span class="nl">borderSide:</span> <span class="n">BorderSide</span><span class="p">(</span><span class="nl">color:</span> <span class="n">Colors</span><span class="p">.</span><span class="n">blue</span><span class="p">),</span>
    <span class="p">),</span>
  <span class="p">),</span>
<span class="p">),</span>
</pre></div>
</div>
<p>上面代码我们直接通过InputDecoration的enabledBorder和focusedBorder来分别设置了输入框在未获取焦点和获得焦点后的下划线颜色。另外，我们也可以通过主题来自定义输入框的样式，下面我们探索一下如何在不使用enabledBorder和focusedBorder的情况下来自定义下滑线颜色。</p>
<p>由于<code class="docutils literal notranslate"><span class="pre">TextField</span></code>在绘制下划线时使用的颜色是主题色里面的<code class="docutils literal notranslate"><span class="pre">hintColor</span></code>，但提示文本颜色也是用的<code class="docutils literal notranslate"><span class="pre">hintColor</span></code>， 如果我们直接修改<code class="docutils literal notranslate"><span class="pre">hintColor</span></code>，那么下划线和提示文本的颜色都会变。值得高兴的是<code class="docutils literal notranslate"><span class="pre">decoration</span></code>中可以设置<code class="docutils literal notranslate"><span class="pre">hintStyle</span></code>，它可以覆盖<code class="docutils literal notranslate"><span class="pre">hintColor</span></code>，并且主题中可以通过<code class="docutils literal notranslate"><span class="pre">inputDecorationTheme</span></code>来设置输入框默认的<code class="docutils literal notranslate"><span class="pre">decoration</span></code>。所以我们可以通过主题来自定义，代码如下：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="n">Theme</span><span class="p">(</span>
  <span class="nl">data:</span> <span class="n">Theme</span><span class="p">.</span><span class="n">of</span><span class="p">(</span><span class="n">context</span><span class="p">).</span><span class="n">copyWith</span><span class="p">(</span>
      <span class="nl">hintColor:</span> <span class="n">Colors</span><span class="p">.</span><span class="n">grey</span><span class="p">[</span><span class="m">200</span><span class="p">],</span> <span class="c1">//定义下划线颜色</span>
      <span class="nl">inputDecorationTheme:</span> <span class="n">InputDecorationTheme</span><span class="p">(</span>
          <span class="nl">labelStyle:</span> <span class="n">TextStyle</span><span class="p">(</span><span class="nl">color:</span> <span class="n">Colors</span><span class="p">.</span><span class="n">grey</span><span class="p">),</span><span class="c1">//定义label字体样式</span>
          <span class="nl">hintStyle:</span> <span class="n">TextStyle</span><span class="p">(</span><span class="nl">color:</span> <span class="n">Colors</span><span class="p">.</span><span class="n">grey</span><span class="p">,</span> <span class="nl">fontSize:</span> <span class="m">14.0</span><span class="p">)</span><span class="c1">//定义提示文本样式</span>
      <span class="p">)</span>
  <span class="p">),</span>
  <span class="nl">child:</span> <span class="n">Column</span><span class="p">(</span>
    <span class="nl">children:</span> <span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">[</span>
      <span class="n">TextField</span><span class="p">(</span>
        <span class="nl">decoration:</span> <span class="n">InputDecoration</span><span class="p">(</span>
            <span class="nl">labelText:</span> <span class="s2">&quot;用户名&quot;</span><span class="p">,</span>
            <span class="nl">hintText:</span> <span class="s2">&quot;用户名或邮箱&quot;</span><span class="p">,</span>
            <span class="nl">prefixIcon:</span> <span class="n">Icon</span><span class="p">(</span><span class="n">Icons</span><span class="p">.</span><span class="n">person</span><span class="p">)</span>
        <span class="p">),</span>
      <span class="p">),</span>
      <span class="n">TextField</span><span class="p">(</span>
        <span class="nl">decoration:</span> <span class="n">InputDecoration</span><span class="p">(</span>
            <span class="nl">prefixIcon:</span> <span class="n">Icon</span><span class="p">(</span><span class="n">Icons</span><span class="p">.</span><span class="n">lock</span><span class="p">),</span>
            <span class="nl">labelText:</span> <span class="s2">&quot;密码&quot;</span><span class="p">,</span>
            <span class="nl">hintText:</span> <span class="s2">&quot;您的登录密码&quot;</span><span class="p">,</span>
            <span class="nl">hintStyle:</span> <span class="n">TextStyle</span><span class="p">(</span><span class="nl">color:</span> <span class="n">Colors</span><span class="p">.</span><span class="n">grey</span><span class="p">,</span> <span class="nl">fontSize:</span> <span class="m">13.0</span><span class="p">)</span>
        <span class="p">),</span>
        <span class="nl">obscureText:</span> <span class="kc">true</span><span class="p">,</span>
      <span class="p">)</span>
    <span class="p">],</span>
  <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>运行效果如图3-28所示：</p>
<p><img alt="图3-28" src="../_images/3-28.png" /></p>
<p>我们成功的自定义了下划线颜色和提问文字样式，细心的读者可能已经发现，通过这种方式自定义后，输入框在获取焦点时，<code class="docutils literal notranslate"><span class="pre">labelText</span></code>不会高亮显示了，正如上图中的”用户名”本应该显示蓝色，但现在却显示为灰色，并且我们还是无法定义下划线宽度。另一种灵活的方式是直接隐藏掉<code class="docutils literal notranslate"><span class="pre">TextField</span></code>本身的下划线，然后通过<code class="docutils literal notranslate"><span class="pre">Container</span></code>去嵌套定义样式，如:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="n">Container</span><span class="p">(</span>
  <span class="nl">child:</span> <span class="n">TextField</span><span class="p">(</span>
    <span class="nl">keyboardType:</span> <span class="n">TextInputType</span><span class="p">.</span><span class="n">emailAddress</span><span class="p">,</span>
    <span class="nl">decoration:</span> <span class="n">InputDecoration</span><span class="p">(</span>
        <span class="nl">labelText:</span> <span class="s2">&quot;Email&quot;</span><span class="p">,</span>
        <span class="nl">hintText:</span> <span class="s2">&quot;电子邮件地址&quot;</span><span class="p">,</span>
        <span class="nl">prefixIcon:</span> <span class="n">Icon</span><span class="p">(</span><span class="n">Icons</span><span class="p">.</span><span class="n">email</span><span class="p">),</span>
        <span class="nl">border:</span> <span class="n">InputBorder</span><span class="p">.</span><span class="n">none</span> <span class="c1">//隐藏下划线</span>
    <span class="p">)</span>
  <span class="p">),</span>
  <span class="nl">decoration:</span> <span class="n">BoxDecoration</span><span class="p">(</span>
      <span class="c1">// 下滑线浅灰色，宽度1像素</span>
      <span class="nl">border:</span> <span class="n">Border</span><span class="p">(</span><span class="nl">bottom:</span> <span class="n">BorderSide</span><span class="p">(</span><span class="nl">color:</span> <span class="n">Colors</span><span class="p">.</span><span class="n">grey</span><span class="p">[</span><span class="m">200</span><span class="p">],</span> <span class="nl">width:</span> <span class="m">1.0</span><span class="p">))</span>
  <span class="p">),</span>
<span class="p">)</span>
</pre></div>
</div>
<p>运行效果：</p>
<p><img alt="image-20180904150511545" src="https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action&#64;1.0/docs/imgs/image-20180904150511545.png" /></p>
<p>通过这种组件组合的方式，也可以定义背景圆角等。一般来说，优先通过<code class="docutils literal notranslate"><span class="pre">decoration</span></code>来自定义样式，如果<code class="docutils literal notranslate"><span class="pre">decoration</span></code>实现不了，再用widget组合的方式。</p>
<blockquote>
<div><p>思考题：在这个示例中，下划线颜色是固定的，所以获得焦点后颜色仍然为灰色，如何实现点击后下滑线也变色呢？</p>
</div></blockquote>
</div>
</div>
</div>
<div class="section" id="form">
<h2>3.7.2 表单Form<a class="headerlink" href="#form" title="Permalink to this headline">¶</a></h2>
<p>实际业务中，在正式向服务器提交数据前，都会对各个输入框数据进行合法性校验，但是对每一个<code class="docutils literal notranslate"><span class="pre">TextField</span></code>都分别进行校验将会是一件很麻烦的事。还有，如果用户想清除一组<code class="docutils literal notranslate"><span class="pre">TextField</span></code>的内容，除了一个一个清除有没有什么更好的办法呢？为此，Flutter提供了一个<code class="docutils literal notranslate"><span class="pre">Form</span></code> 组件，它可以对输入框进行分组，然后进行一些统一操作，如输入内容校验、输入框重置以及输入内容保存。</p>
<div class="section" id="id9">
<h3>Form<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Form</span></code>继承自<code class="docutils literal notranslate"><span class="pre">StatefulWidget</span></code>对象，它对应的状态类为<code class="docutils literal notranslate"><span class="pre">FormState</span></code>。我们先看看<code class="docutils literal notranslate"><span class="pre">Form</span></code>类的定义：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span>Form({
  @required Widget child,
  bool autovalidate = false,
  WillPopCallback onWillPop,
  VoidCallback onChanged,
})
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">autovalidate</span></code>：是否自动校验输入内容；当为<code class="docutils literal notranslate"><span class="pre">true</span></code>时，每一个子FormField内容发生变化时都会自动校验合法性，并直接显示错误信息。否则，需要通过调用<code class="docutils literal notranslate"><span class="pre">FormState.validate()</span></code>来手动校验。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">onWillPop</span></code>：决定<code class="docutils literal notranslate"><span class="pre">Form</span></code>所在的路由是否可以直接返回（如点击返回按钮），该回调返回一个<code class="docutils literal notranslate"><span class="pre">Future</span></code>对象，如果Future的最终结果是<code class="docutils literal notranslate"><span class="pre">false</span></code>，则当前路由不会返回；如果为<code class="docutils literal notranslate"><span class="pre">true</span></code>，则会返回到上一个路由。此属性通常用于拦截返回按钮。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">onChanged</span></code>：<code class="docutils literal notranslate"><span class="pre">Form</span></code>的任意一个子<code class="docutils literal notranslate"><span class="pre">FormField</span></code>内容发生变化时会触发此回调。</p></li>
</ul>
</div>
<div class="section" id="formfield">
<h3>FormField<a class="headerlink" href="#formfield" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Form</span></code>的子孙元素必须是<code class="docutils literal notranslate"><span class="pre">FormField</span></code>类型，<code class="docutils literal notranslate"><span class="pre">FormField</span></code>是一个抽象类，定义几个属性，<code class="docutils literal notranslate"><span class="pre">FormState</span></code>内部通过它们来完成操作，<code class="docutils literal notranslate"><span class="pre">FormField</span></code>部分定义如下：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span> <span class="n">FormField</span><span class="p">({</span>
  <span class="p">...</span>
  <span class="n">FormFieldSetter</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">onSaved</span><span class="p">,</span> <span class="c1">//保存回调</span>
  <span class="n">FormFieldValidator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>  <span class="n">validator</span><span class="p">,</span> <span class="c1">//验证回调</span>
  <span class="n">T</span> <span class="n">initialValue</span><span class="p">,</span> <span class="c1">//初始值</span>
  <span class="kt">bool</span> <span class="n">autovalidate</span> <span class="o">=</span> <span class="kc">false</span><span class="p">,</span> <span class="c1">//是否自动校验。</span>
<span class="p">})</span>
</pre></div>
</div>
<p>为了方便使用，Flutter提供了一个<code class="docutils literal notranslate"><span class="pre">TextFormField</span></code>组件，它继承自<code class="docutils literal notranslate"><span class="pre">FormField</span></code>类，也是<code class="docutils literal notranslate"><span class="pre">TextField</span></code>的一个包装类，所以除了<code class="docutils literal notranslate"><span class="pre">FormField</span></code>定义的属性之外，它还包括<code class="docutils literal notranslate"><span class="pre">TextField</span></code>的属性。</p>
</div>
<div class="section" id="formstate">
<h3>FormState<a class="headerlink" href="#formstate" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">FormState</span></code>为<code class="docutils literal notranslate"><span class="pre">Form</span></code>的<code class="docutils literal notranslate"><span class="pre">State</span></code>类，可以通过<code class="docutils literal notranslate"><span class="pre">Form.of()</span></code>或<code class="docutils literal notranslate"><span class="pre">GlobalKey</span></code>获得。我们可以通过它来对<code class="docutils literal notranslate"><span class="pre">Form</span></code>的子孙<code class="docutils literal notranslate"><span class="pre">FormField</span></code>进行统一操作。我们看看其常用的三个方法：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">FormState.validate()</span></code>：调用此方法后，会调用<code class="docutils literal notranslate"><span class="pre">Form</span></code>子孙<code class="docutils literal notranslate"><span class="pre">FormField的validate</span></code>回调，如果有一个校验失败，则返回false，所有校验失败项都会返回用户返回的错误提示。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FormState.save()</span></code>：调用此方法后，会调用<code class="docutils literal notranslate"><span class="pre">Form</span></code>子孙<code class="docutils literal notranslate"><span class="pre">FormField</span></code>的<code class="docutils literal notranslate"><span class="pre">save</span></code>回调，用于保存表单内容</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FormState.reset()</span></code>：调用此方法后，会将子孙<code class="docutils literal notranslate"><span class="pre">FormField</span></code>的内容清空。</p></li>
</ul>
</div>
<div class="section" id="id10">
<h3>示例<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<p>我们修改一下上面用户登录的示例，在提交之前校验：</p>
<ol class="simple">
<li><p>用户名不能为空，如果为空则提示“用户名不能为空”。</p></li>
<li><p>密码不能小于6位，如果小于6为则提示“密码不能少于6位”。</p></li>
</ol>
<p>完整代码：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span>class FormTestRoute extends StatefulWidget {
  @override
  _FormTestRouteState createState() =&gt; new _FormTestRouteState();
}

class _FormTestRouteState extends State&lt;FormTestRoute&gt; {
  TextEditingController _unameController = new TextEditingController();
  TextEditingController _pwdController = new TextEditingController();
  GlobalKey _formKey= new GlobalKey&lt;FormState&gt;();

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title:Text(&quot;Form Test&quot;),
      ),
      body: Padding(
        padding: const EdgeInsets.symmetric(vertical: 16.0, horizontal: 24.0),
        child: Form(
          key: _formKey, //设置globalKey，用于后面获取FormState
          autovalidate: true, //开启自动校验
          child: Column(
            children: &lt;Widget&gt;[
              TextFormField(
                  autofocus: true,
                  controller: _unameController,
                  decoration: InputDecoration(
                      labelText: &quot;用户名&quot;,
                      hintText: &quot;用户名或邮箱&quot;,
                      icon: Icon(Icons.person)
                  ),
                  // 校验用户名
                  validator: (v) {
                    return v
                        .trim()
                        .length &gt; 0 ? null : &quot;用户名不能为空&quot;;
                  }

              ),
              TextFormField(
                  controller: _pwdController,
                  decoration: InputDecoration(
                      labelText: &quot;密码&quot;,
                      hintText: &quot;您的登录密码&quot;,
                      icon: Icon(Icons.lock)
                  ),
                  obscureText: true,
                  //校验密码
                  validator: (v) {
                    return v
                        .trim()
                        .length &gt; 5 ? null : &quot;密码不能少于6位&quot;;
                  }
              ),
              // 登录按钮
              Padding(
                padding: const EdgeInsets.only(top: 28.0),
                child: Row(
                  children: &lt;Widget&gt;[
                    Expanded(
                      child: RaisedButton(
                        padding: EdgeInsets.all(15.0),
                        child: Text(&quot;登录&quot;),
                        color: Theme
                            .of(context)
                            .primaryColor,
                        textColor: Colors.white,
                        onPressed: () {
                          //在这里不能通过此方式获取FormState，context不对
                          //print(Form.of(context));
                            
                          // 通过_formKey.currentState 获取FormState后，
                          // 调用validate()方法校验用户名密码是否合法，校验
                          // 通过后再提交数据。 
                          if((_formKey.currentState as FormState).validate()){
                            //验证通过提交数据
                          }
                        },
                      ),
                    ),
                  ],
                ),
              )
            ],
          ),
        ),
      ),
    );
  }
}
</pre></div>
</div>
<p>运行后效果如图3-29所示：</p>
<p><img alt="图3-29" src="../_images/3-29.png" /></p>
<p>注意，登录按钮的<code class="docutils literal notranslate"><span class="pre">onPressed</span></code>方法中不能通过<code class="docutils literal notranslate"><span class="pre">Form.of(context)</span></code>来获取，原因是，此处的<code class="docutils literal notranslate"><span class="pre">context</span></code>为<code class="docutils literal notranslate"><span class="pre">FormTestRoute</span></code>的context，而<code class="docutils literal notranslate"><span class="pre">Form.of(context)</span></code>是根据所指定<code class="docutils literal notranslate"><span class="pre">context</span></code>向根去查找，而<code class="docutils literal notranslate"><span class="pre">FormState</span></code>是在<code class="docutils literal notranslate"><span class="pre">FormTestRoute</span></code>的子树中，所以不行。正确的做法是通过<code class="docutils literal notranslate"><span class="pre">Builder</span></code>来构建登录按钮，<code class="docutils literal notranslate"><span class="pre">Builder</span></code>会将<code class="docutils literal notranslate"><span class="pre">widget</span></code>节点的<code class="docutils literal notranslate"><span class="pre">context</span></code>作为回调参数：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="n">Expanded</span><span class="p">(</span>
 <span class="c1">// 通过Builder来获取RaisedButton所在widget树的真正context(Element) </span>
  <span class="nl">child:</span><span class="n">Builder</span><span class="p">(</span><span class="nl">builder:</span> <span class="p">(</span><span class="n">context</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">RaisedButton</span><span class="p">(</span>
      <span class="p">...</span>
      <span class="nl">onPressed:</span> <span class="p">()</span> <span class="p">{</span>
        <span class="c1">//由于本widget也是Form的子代widget，所以可以通过下面方式获取FormState  </span>
        <span class="k">if</span><span class="p">(</span><span class="n">Form</span><span class="p">.</span><span class="n">of</span><span class="p">(</span><span class="n">context</span><span class="p">).</span><span class="n">validate</span><span class="p">()){</span>
          <span class="c1">//验证通过提交数据</span>
        <span class="p">}</span>
      <span class="p">},</span>
    <span class="p">);</span>
  <span class="p">})</span>
<span class="p">)</span>
</pre></div>
</div>
<p>其实<code class="docutils literal notranslate"><span class="pre">context</span></code>正是操作Widget所对应的<code class="docutils literal notranslate"><span class="pre">Element</span></code>的一个接口，由于Widget树对应的<code class="docutils literal notranslate"><span class="pre">Element</span></code>都是不同的，所以<code class="docutils literal notranslate"><span class="pre">context</span></code>也都是不同的，有关<code class="docutils literal notranslate"><span class="pre">context</span></code>的更多内容会在后面高级部分详细讨论。Flutter中有很多“of(context)”这种方法，读者在使用时一定要注意<code class="docutils literal notranslate"><span class="pre">context</span></code>是否正确。</p>
</div>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">flutter in action</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, mahongquan.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.5.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/chapter3/input_and_form.md.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>