
<!DOCTYPE html>

<html lang="zh-cn">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>12.6 Texture和PlatformView &#8212; flutter in action 1.0 documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="textureplatformview">
<h1>12.6 Texture和PlatformView<a class="headerlink" href="#textureplatformview" title="Permalink to this headline">¶</a></h1>
<p>本节主要介绍原生和Flutter之间如何共享图像，以及如何在Flutter中嵌套原生组件。</p>
<div class="section" id="texture">
<h2>12.6.1 Texture（示例：使用摄像头）<a class="headerlink" href="#texture" title="Permalink to this headline">¶</a></h2>
<p>前面说过Flutter本身只是一个UI系统，对于一些系统能力的调用我们可以通过消息传送机制与原生交互。但是这种消息传送机制并不能覆盖所有的应用场景，比如我们想调用摄像头来拍照或录视频，但在拍照和录视频的过程中我们需要将预览画面显示到我们的Flutter UI中，如果我们要用Flutter定义的消息通道机制来实现这个功能，就需要将摄像头采集的每一帧图片都要从原生传递到Flutter中，这样做代价将会非常大，因为将图像或视频数据通过消息通道实时传输必然会引起内存和CPU的巨大消耗！为此，Flutter提供了一种基于Texture的图片数据共享机制。</p>
<p>Texture可以理解为GPU内保存将要绘制的图像数据的一个对象，Flutter engine会将Texture的数据在内存中直接进行映射（而无需在原生和Flutter之间再进行数据传递），Flutter会给每一个Texture分配一个id，同时Flutter中提供了一个<code class="docutils literal notranslate"><span class="pre">Texture</span></code>组件，<code class="docutils literal notranslate"><span class="pre">Texture</span></code>构造函数定义如下：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span>const Texture({
  Key key,
  @required this.textureId,
})
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Texture</span></code> 组件正是通过<code class="docutils literal notranslate"><span class="pre">textureId</span></code>与Texture数据关联起来；在<code class="docutils literal notranslate"><span class="pre">Texture</span></code>组件绘制时，Flutter会自动从内存中找到相应id的Texture数据，然后进行绘制。可以总结一下整个流程：图像数据先在原生部分缓存，然后在Flutter部分再通过<code class="docutils literal notranslate"><span class="pre">textureId</span></code>和缓存关联起来，最后绘制由Flutter完成。</p>
<p>如果我们作为一个插件开发者，我们在原生代码中分配了<code class="docutils literal notranslate"><span class="pre">textureId</span></code>，那么在Flutter侧使用<code class="docutils literal notranslate"><span class="pre">Texture</span></code>组件时要如何获取<code class="docutils literal notranslate"><span class="pre">textureId</span></code>呢？这又回到了之前的内容了，<code class="docutils literal notranslate"><span class="pre">textureId</span></code>完全可以通过MethodChannel来传递。</p>
<p>另外，值得注意的是，当原生摄像头捕获的图像发生变化时，<code class="docutils literal notranslate"><span class="pre">Texture</span></code> 组件会自动重绘，这不需要我们写任何Dart 代码去控制。</p>
<div class="section" id="id1">
<h3>Texture用法<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>如果我们要手动实现一个相机插件，和前面几节介绍的“获取剩余电量”插件的步骤一样，需要分别实现原生部分和Flutter部分。考虑到大多数读者可能并非同时既了解Android开发，又了解iOS开发，如果我们再花大量篇幅来介绍不同端的实现可能会没什么意义，另外，由于Flutter官方提供的相机（camera）插件和视频播放（video_player）插件都是使用Texture来实现的，它们本身就是Texture非常好的示例，所以在本书中将不会再介绍使用Texture的具体流程了，读者有兴趣查看camera和video_player的实现代码。下面我们重点介绍一下如何使用camera和video_player。</p>
</div>
<div class="section" id="id2">
<h3>相机示例<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>下面我们看一下camera包自带的一个示例，它包含如下功能：</p>
<ol class="simple">
<li><p>可以拍照，也可以拍视频，拍摄完成后可以保存；排号的视频可以播放预览。</p></li>
<li><p>可以切换摄像头（前置摄像头、后置摄像头、其它）</p></li>
<li><p>可以显示已经拍摄内容的预览图。</p></li>
</ol>
<p>下面我们看一下具体代码：</p>
<ol>
<li><p>首先，依赖camera插件的最新版，并下载依赖。</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">dependencies</span><span class="p p-Indicator">:</span>
  <span class="l l-Scalar l-Scalar-Plain">...  //省略无关代码</span>
  <span class="l l-Scalar l-Scalar-Plain">camera</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">^0.5.2+2</span>
</pre></div>
</div>
</li>
<li><p>在<code class="docutils literal notranslate"><span class="pre">main</span></code>方法中获取可用摄像头列表。</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">main</span><span class="p">()</span> <span class="kd">async</span> <span class="p">{</span>
  <span class="c1">// 获取可用摄像头列表，cameras为全局变量</span>
  <span class="n">cameras</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">availableCameras</span><span class="p">();</span>
  <span class="n">runApp</span><span class="p">(</span><span class="n">MyApp</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>构建UI。现在我们构建如图12-4的测试界面：</p>
<p><img alt="12-4" src="../_images/12-4.jpg" />
线面是完整的代码：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span>import &#39;package:camera/camera.dart&#39;;
import &#39;package:flutter/material.dart&#39;;
import &#39;../common.dart&#39;;
import &#39;dart:async&#39;;
import &#39;dart:io&#39;;
import &#39;package:path_provider/path_provider.dart&#39;;
import &#39;package:video_player/video_player.dart&#39;; //用于播放录制的视频

/// 获取不同摄像头的图标（前置、后置、其它）
IconData getCameraLensIcon(CameraLensDirection direction) {
  switch (direction) {
    case CameraLensDirection.back:
      return Icons.camera_rear;
    case CameraLensDirection.front:
      return Icons.camera_front;
    case CameraLensDirection.external:
      return Icons.camera;
  }
  throw ArgumentError(&#39;Unknown lens direction&#39;);
}

void logError(String code, String message) =&gt;
    print(&#39;Error: $code\nError Message: $message&#39;);

// 示例页面路由
class CameraExampleHome extends StatefulWidget {
  @override
  _CameraExampleHomeState createState() {
    return _CameraExampleHomeState();
  }
}

class _CameraExampleHomeState extends State&lt;CameraExampleHome&gt;
    with WidgetsBindingObserver {
  CameraController controller;
  String imagePath; // 图片保存路径
  String videoPath; //视频保存路径
  VideoPlayerController videoController;
  VoidCallback videoPlayerListener;
  bool enableAudio = true;

  @override
  void initState() {
    super.initState();
    // 监听APP状态改变，是否在前台
    WidgetsBinding.instance.addObserver(this);
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    // 如果APP不在在前台
    if (state == AppLifecycleState.inactive) {
      controller?.dispose();
    } else if (state == AppLifecycleState.resumed) {
      // 在前台
      if (controller != null) {
        onNewCameraSelected(controller.description);
      }
    }
  }

  final GlobalKey&lt;ScaffoldState&gt; _scaffoldKey = GlobalKey&lt;ScaffoldState&gt;();

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      key: _scaffoldKey,
      appBar: AppBar(
        title: const Text(&#39;相机示例&#39;),
      ),
      body: Column(
        children: &lt;Widget&gt;[
          Expanded(
            child: Container(
              child: Padding(
                padding: const EdgeInsets.all(1.0),
                child: Center(
                  child: _cameraPreviewWidget(),
                ),
              ),
              decoration: BoxDecoration(
                color: Colors.black,
                border: Border.all(
                  color: controller != null &amp;&amp; controller.value.isRecordingVideo
                      ? Colors.redAccent
                      : Colors.grey,
                  width: 3.0,
                ),
              ),
            ),
          ),
          _captureControlRowWidget(),
          _toggleAudioWidget(),
          Padding(
            padding: const EdgeInsets.all(5.0),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.start,
              children: &lt;Widget&gt;[
                _cameraTogglesRowWidget(),
                _thumbnailWidget(),
              ],
            ),
          ),
        ],
      ),
    );
  }

  /// 展示预览窗口
  Widget _cameraPreviewWidget() {
    if (controller == null || !controller.value.isInitialized) {
      return const Text(
        &#39;选择一个摄像头&#39;,
        style: TextStyle(
          color: Colors.white,
          fontSize: 24.0,
          fontWeight: FontWeight.w900,
        ),
      );
    } else {
      return AspectRatio(
        aspectRatio: controller.value.aspectRatio,
        child: CameraPreview(controller),
      );
    }
  }

  /// 开启或关闭录音
  Widget _toggleAudioWidget() {
    return Padding(
      padding: const EdgeInsets.only(left: 25),
      child: Row(
        children: &lt;Widget&gt;[
          const Text(&#39;开启录音:&#39;),
          Switch(
            value: enableAudio,
            onChanged: (bool value) {
              enableAudio = value;
              if (controller != null) {
                onNewCameraSelected(controller.description);
              }
            },
          ),
        ],
      ),
    );
  }

  /// 显示已拍摄的图片/视频缩略图。
  Widget _thumbnailWidget() {
    return Expanded(
      child: Align(
        alignment: Alignment.centerRight,
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: &lt;Widget&gt;[
            videoController == null &amp;&amp; imagePath == null
                ? Container()
                : SizedBox(
              child: (videoController == null)
                  ? Image.file(File(imagePath))
                  : Container(
                child: Center(
                  child: AspectRatio(
                      aspectRatio:
                      videoController.value.size != null
                          ? videoController.value.aspectRatio
                          : 1.0,
                      child: VideoPlayer(videoController)),
                ),
                decoration: BoxDecoration(
                    border: Border.all(color: Colors.pink)),
              ),
              width: 64.0,
              height: 64.0,
            ),
          ],
        ),
      ),
    );
  }

  /// 相机工具栏
  Widget _captureControlRowWidget() {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
      mainAxisSize: MainAxisSize.max,
      children: &lt;Widget&gt;[
        IconButton(
          icon: const Icon(Icons.camera_alt),
          color: Colors.blue,
          onPressed: controller != null &amp;&amp;
              controller.value.isInitialized &amp;&amp;
              !controller.value.isRecordingVideo
              ? onTakePictureButtonPressed
              : null,
        ),
        IconButton(
          icon: const Icon(Icons.videocam),
          color: Colors.blue,
          onPressed: controller != null &amp;&amp;
              controller.value.isInitialized &amp;&amp;
              !controller.value.isRecordingVideo
              ? onVideoRecordButtonPressed
              : null,
        ),
        IconButton(
          icon: const Icon(Icons.stop),
          color: Colors.red,
          onPressed: controller != null &amp;&amp;
              controller.value.isInitialized &amp;&amp;
              controller.value.isRecordingVideo
              ? onStopButtonPressed
              : null,
        )
      ],
    );
  }

  /// 展示所有摄像头
  Widget _cameraTogglesRowWidget() {
    final List&lt;Widget&gt; toggles = &lt;Widget&gt;[];

    if (cameras.isEmpty) {
      return const Text(&#39;没有检测到摄像头&#39;);
    } else {
      for (CameraDescription cameraDescription in cameras) {
        toggles.add(
          SizedBox(
            width: 90.0,
            child: RadioListTile&lt;CameraDescription&gt;(
              title: Icon(getCameraLensIcon(cameraDescription.lensDirection)),
              groupValue: controller?.description,
              value: cameraDescription,
              onChanged: controller != null &amp;&amp; controller.value.isRecordingVideo
                  ? null
                  : onNewCameraSelected,
            ),
          ),
        );
      }
    }

    return Row(children: toggles);
  }

  String timestamp() =&gt; DateTime.now().millisecondsSinceEpoch.toString();

  void showInSnackBar(String message) {
    _scaffoldKey.currentState.showSnackBar(SnackBar(content: Text(message)));
  }

  // 摄像头选中回调
  void onNewCameraSelected(CameraDescription cameraDescription) async {
    if (controller != null) {
      await controller.dispose();
    }
    controller = CameraController(
      cameraDescription,
      ResolutionPreset.high,
      enableAudio: enableAudio,
    );

    controller.addListener(() {
      if (mounted) setState(() {});
      if (controller.value.hasError) {
        showInSnackBar(&#39;Camera error ${controller.value.errorDescription}&#39;);
      }
    });

    try {
      await controller.initialize();
    } on CameraException catch (e) {
      _showCameraException(e);
    }

    if (mounted) {
      setState(() {});
    }
  }

  // 拍照按钮点击回调
  void onTakePictureButtonPressed() {
    takePicture().then((String filePath) {
      if (mounted) {
        setState(() {
          imagePath = filePath;
          videoController?.dispose();
          videoController = null;
        });
        if (filePath != null) showInSnackBar(&#39;图片保存在 $filePath&#39;);
      }
    });
  }

  // 开始录制视频
  void onVideoRecordButtonPressed() {
    startVideoRecording().then((String filePath) {
      if (mounted) setState(() {});
      if (filePath != null) showInSnackBar(&#39;正在保存视频于 $filePath&#39;);
    });
  }

  // 终止视频录制
  void onStopButtonPressed() {
    stopVideoRecording().then((_) {
      if (mounted) setState(() {});
      showInSnackBar(&#39;视频保存在: $videoPath&#39;);
    });
  }

  Future&lt;String&gt; startVideoRecording() async {
    if (!controller.value.isInitialized) {
      showInSnackBar(&#39;请先选择一个摄像头&#39;);
      return null;
    }

    // 确定视频保存的路径
    final Directory extDir = await getApplicationDocumentsDirectory();
    final String dirPath = &#39;${extDir.path}/Movies/flutter_test&#39;;
    await Directory(dirPath).create(recursive: true);
    final String filePath = &#39;$dirPath/${timestamp()}.mp4&#39;;

    if (controller.value.isRecordingVideo) {
      // 如果正在录制，则直接返回
      return null;
    }

    try {
      videoPath = filePath;
      await controller.startVideoRecording(filePath);
    } on CameraException catch (e) {
      _showCameraException(e);
      return null;
    }
    return filePath;
  }

  Future&lt;void&gt; stopVideoRecording() async {
    if (!controller.value.isRecordingVideo) {
      return null;
    }

    try {
      await controller.stopVideoRecording();
    } on CameraException catch (e) {
      _showCameraException(e);
      return null;
    }

    await _startVideoPlayer();
  }

  Future&lt;void&gt; _startVideoPlayer() async {
    final VideoPlayerController vcontroller =
    VideoPlayerController.file(File(videoPath));
    videoPlayerListener = () {
      if (videoController != null &amp;&amp; videoController.value.size != null) {
        // Refreshing the state to update video player with the correct ratio.
        if (mounted) setState(() {});
        videoController.removeListener(videoPlayerListener);
      }
    };
    vcontroller.addListener(videoPlayerListener);
    await vcontroller.setLooping(true);
    await vcontroller.initialize();
    await videoController?.dispose();
    if (mounted) {
      setState(() {
        imagePath = null;
        videoController = vcontroller;
      });
    }
    await vcontroller.play();
  }

  Future&lt;String&gt; takePicture() async {
    if (!controller.value.isInitialized) {
      showInSnackBar(&#39;错误: 请先选择一个相机&#39;);
      return null;
    }
    final Directory extDir = await getApplicationDocumentsDirectory();
    final String dirPath = &#39;${extDir.path}/Pictures/flutter_test&#39;;
    await Directory(dirPath).create(recursive: true);
    final String filePath = &#39;$dirPath/${timestamp()}.jpg&#39;;

    if (controller.value.isTakingPicture) {
      // A capture is already pending, do nothing.
      return null;
    }

    try {
      await controller.takePicture(filePath);
    } on CameraException catch (e) {
      _showCameraException(e);
      return null;
    }
    return filePath;
  }

  void _showCameraException(CameraException e) {
    logError(e.code, e.description);
    showInSnackBar(&#39;Error: ${e.code}\n${e.description}&#39;);
  }
}
</pre></div>
</div>
</li>
</ol>
<blockquote>
<div><p>如果代码运行遇到困难，请直接查看<a class="reference external" href="https://pub.dev/packages/camera">camera官方文档</a>。</p>
</div></blockquote>
</div>
</div>
<div class="section" id="platformview-webview">
<h2>12.6.2 PlatformView （示例：WebView）<a class="headerlink" href="#platformview-webview" title="Permalink to this headline">¶</a></h2>
<p>如果我们在开发过程中需要使用一个原生组件，但这个原生组件在Flutter中很难实现时怎么办（如webview）？这时一个简单的方法就是将需要使用原生组件的页面全部用原生实现，在flutter中需要打开该页面时通过消息通道打开这个原生的页面。但是这种方法有一个最大的缺点，就是原生组件很难和Flutter组件进行组合。</p>
<p>在 Flutter 1.0版本中，Flutter SDK中新增了<code class="docutils literal notranslate"><span class="pre">AndroidView</span></code>和<code class="docutils literal notranslate"><span class="pre">UIKitView</span></code> 两个组件，这两个组件的主要功能就是将原生的Android组件和iOS组件嵌入到Flutter的组件树中，这个功能是非常重要的，尤其是对一些实现非常复杂的组件，比如webview，这些组件原生已经有了，如果Flutter中要用，重新实现的话成本将非常高，所以如果有一种机制能让Flutter共享原生组件，这将会非常有用，也正因如此，Flutter才提供了这两个组件。</p>
<p>由于<code class="docutils literal notranslate"><span class="pre">AndroidView</span></code>和<code class="docutils literal notranslate"><span class="pre">UIKitView</span></code> 是和具体平台相关的，所以称它们为PlatformView。需要说明的是将来Flutter支持的平台可能会增多，则相应的PlatformView也将会变多。那么如何使用Platform View呢？我们以Flutter官方提供的<a class="reference external" href="https://github.com/flutter/plugins/tree/master/packages/webview_flutter">webview_flutter插件</a>为例：</p>
<blockquote>
<div><p>注意，在本书写作之时，webview_flutter仍处于预览阶段，如您想在项目中使用它，请查看一下webview_flutter插件最新版本及动态。</p>
</div></blockquote>
<ol>
<li><p>原生代码中注册要被Flutter嵌入的组件工厂，如webview_flutter插件中Android端注册webview插件代码：</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">registerWith</span><span class="o">(</span><span class="n">Registrar</span> <span class="n">registrar</span><span class="o">)</span> <span class="o">{</span>
   <span class="n">registrar</span><span class="o">.</span><span class="na">platformViewRegistry</span><span class="o">().</span><span class="na">registerViewFactory</span><span class="o">(</span><span class="s">&quot;webview&quot;</span><span class="o">,</span> 
   <span class="n">WebViewFactory</span><span class="o">(</span><span class="n">registrar</span><span class="o">.</span><span class="na">messenger</span><span class="o">()));</span>
<span class="o">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">WebViewFactory</span></code>的具体实现请参考webview_flutter插件的实现源码，在此不再赘述。</p>
</li>
<li><p>在Flutter中使用；打开Flutter中文社区首页。</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span>class PlatformViewRoute extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return WebView(
      initialUrl: &quot;https://flutterchina.club&quot;,
      javascriptMode: JavascriptMode.unrestricted,
    );
  }
}
</pre></div>
</div>
<p>运行效果如图12-5所示：</p>
<p><img alt="12-5" src="../_images/12-5.jpg" /></p>
</li>
</ol>
<p>注意，使用PlatformView的开销是非常大的，因此，如果一个原生组件用Flutter实现的难度不大时，我们应该首选Flutter实现。</p>
<p>另外，PlatformView的相关功能在作者写作时还处于预览阶段，可能还会发生变化，因此，读者如果需要在项目中使用的话，应查看一下最新的文档。</p>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">flutter in action</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, mahongquan.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.5.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/chapter12/texture_platformview.md.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>