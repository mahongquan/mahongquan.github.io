
<!DOCTYPE html>

<html lang="zh-cn">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>10.3 组合实例：TurnBox &#8212; flutter in action 1.0 documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="turnbox">
<h1>10.3 组合实例：TurnBox<a class="headerlink" href="#turnbox" title="Permalink to this headline">¶</a></h1>
<p>我们之前已经介绍过<code class="docutils literal notranslate"><span class="pre">RotatedBox</span></code>，它可以旋转子组件，但是它有两个缺点：一是只能将其子节点以90度的倍数旋转；二是当旋转的角度发生变化时，旋转角度更新过程没有动画。</p>
<p>本节我们将实现一个<code class="docutils literal notranslate"><span class="pre">TurnBox</span></code>组件，它不仅可以以任意角度来旋转其子节点，而且可以在角度发生变化时执行一个动画以过渡到新状态，同时，我们可以手动指定动画速度。</p>
<p><code class="docutils literal notranslate"><span class="pre">TurnBox</span></code>的完整代码如下：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span>import &#39;package:flutter/widgets.dart&#39;;

class TurnBox extends StatefulWidget {
  const TurnBox({
    Key key,
    this.turns = .0, //旋转的“圈”数,一圈为360度，如0.25圈即90度
    this.speed = 200, //过渡动画执行的总时长
    this.child
  }) :super(key: key);

  final double turns;
  final int speed;
  final Widget child;

  @override
  _TurnBoxState createState() =&gt; new _TurnBoxState();
}

class _TurnBoxState extends State&lt;TurnBox&gt;
    with SingleTickerProviderStateMixin {
  AnimationController _controller;

  @override
  void initState() {
    super.initState();
    _controller = new AnimationController(
        vsync: this,
        lowerBound: -double.infinity,
        upperBound: double.infinity
    );
    _controller.value = widget.turns;
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return RotationTransition(
      turns: _controller,
      child: widget.child,
    );
  }

  @override
  void didUpdateWidget(TurnBox oldWidget) {
    super.didUpdateWidget(oldWidget);
    //旋转角度发生变化时执行过渡动画  
    if (oldWidget.turns != widget.turns) {
      _controller.animateTo(
        widget.turns,
        duration: Duration(milliseconds: widget.speed??200),
        curve: Curves.easeOut,
      );
    }
  }
}
</pre></div>
</div>
<p>上面代码中：</p>
<ol class="simple">
<li><p>我们是通过组合<code class="docutils literal notranslate"><span class="pre">RotationTransition</span></code>和child来实现的旋转效果。</p></li>
<li><p>在<code class="docutils literal notranslate"><span class="pre">didUpdateWidget</span></code>中，我们判断要旋转的角度是否发生了变化，如果变了，则执行一个过渡动画。</p></li>
</ol>
<p>下面我们测试一下<code class="docutils literal notranslate"><span class="pre">TurnBox</span></code>的功能，测试代码如下：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span>import &#39;package:flutter/material.dart&#39;;
import &#39;../widgets/index.dart&#39;;

class TurnBoxRoute extends StatefulWidget {
  @override
  _TurnBoxRouteState createState() =&gt; new _TurnBoxRouteState();
}

class _TurnBoxRouteState extends State&lt;TurnBoxRoute&gt; {
  double _turns = .0;

  @override
  Widget build(BuildContext context) {

    return Center(
      child: Column(
        children: &lt;Widget&gt;[
          TurnBox(
            turns: _turns,
            speed: 500,
            child: Icon(Icons.refresh, size: 50,),
          ),
          TurnBox(
            turns: _turns,
            speed: 1000,
            child: Icon(Icons.refresh, size: 150.0,),
          ),
          RaisedButton(
            child: Text(&quot;顺时针旋转1/5圈&quot;),
            onPressed: () {
              setState(() {
                _turns += .2;
              });
            },
          ),
          RaisedButton(
            child: Text(&quot;逆时针旋转1/5圈&quot;),
            onPressed: () {
              setState(() {
                _turns -= .2;
              });
            },
          )
        ],
      ),
    );
  }
}
</pre></div>
</div>
<p>测试代码运行后效果如图10-2所示：</p>
<p><img alt="图10-2" src="../_images/10-2.png" /></p>
<p>当我们点击旋转按钮时，两个图标的旋转都会旋转1/5圈，但旋转的速度是不同的，读者可以自己运行一下示例看看效果。</p>
<p>实际上本示例只组合了<code class="docutils literal notranslate"><span class="pre">RotationTransition</span></code>一个组件，它是一个最简的组合类组件示例。另外，如果我们封装的是<code class="docutils literal notranslate"><span class="pre">StatefulWidget</span></code>，那么一定要注意在组件更新时是否需要同步状态。比如我们要封装一个富文本展示组件<code class="docutils literal notranslate"><span class="pre">MyRichText</span></code> ，它可以自动处理url链接，定义如下：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span>class MyRichText extends StatefulWidget {
  MyRichText({
    Key key,
    this.text, // 文本字符串
    this.linkStyle, // url链接样式
  }) : super(key: key);

  final String text;
  final TextStyle linkStyle;

  @override
  _MyRichTextState createState() =&gt; _MyRichTextState();
}
</pre></div>
</div>
<p>接下来我们在<code class="docutils literal notranslate"><span class="pre">_MyRichTextState</span></code>中要实现的功能有两个：</p>
<ol class="simple">
<li><p>解析文本字符串“text”，生成<code class="docutils literal notranslate"><span class="pre">TextSpan</span></code>缓存起来；</p></li>
<li><p>在<code class="docutils literal notranslate"><span class="pre">build</span></code>中返回最终的富文本样式；</p></li>
</ol>
<p><code class="docutils literal notranslate"><span class="pre">_MyRichTextState</span></code> 实现的代码大致如下：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span>class _MyRichTextState extends State&lt;MyRichText&gt; {

  TextSpan _textSpan;

  @override
  Widget build(BuildContext context) {
    return RichText(
      text: _textSpan,
    );
  }

  TextSpan parseText(String text) {
    // 耗时操作：解析文本字符串，构建出TextSpan。
    // 省略具体实现。
  }

  @override
  void initState() {
    _textSpan = parseText(widget.text)
    super.initState();
  }
}
</pre></div>
</div>
<p>由于解析文本字符串，构建出<code class="docutils literal notranslate"><span class="pre">TextSpan</span></code>是一个耗时操作，为了不在每次build的时候都解析一次，所以我们在<code class="docutils literal notranslate"><span class="pre">initState</span></code>中对解析的结果进行了缓存，然后再<code class="docutils literal notranslate"><span class="pre">build</span></code>中直接使用解析的结果<code class="docutils literal notranslate"><span class="pre">_textSpan</span></code>。这看起来很不错，但是上面的代码有一个严重的问题，就是父组件传入的<code class="docutils literal notranslate"><span class="pre">text</span></code>发生变化时（组件树结构不变），那么<code class="docutils literal notranslate"><span class="pre">MyRichText</span></code>显示的内容不会更新，原因就是<code class="docutils literal notranslate"><span class="pre">initState</span></code>只会在State创建时被调用，所以在<code class="docutils literal notranslate"><span class="pre">text</span></code>发生变化时，<code class="docutils literal notranslate"><span class="pre">parseText</span></code>没有重新执行，导致<code class="docutils literal notranslate"><span class="pre">_textSpan</span></code>任然是旧的解析值。要解决这个问题也很简单，我们只需添加一个<code class="docutils literal notranslate"><span class="pre">didUpdateWidget</span></code>回调，然后再里面重新调用<code class="docutils literal notranslate"><span class="pre">parseText</span></code>即可：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span>@override
void didUpdateWidget(MyRichText oldWidget) {
  if (widget.text != oldWidget.text) {
    _textSpan = parseText(widget.text);
  }
  super.didUpdateWidget(oldWidget);
}
</pre></div>
</div>
<p>有些读者可能会觉得这个点也很简单，是的，的确很简单，之所以要在这里反复强调是因为这个点在实际开发中很容易被忽略，它虽然简单，但却很重要。总之，当我们在State中会缓存某些依赖Widget参数的数据时，一定要注意在组件更新时是否需要同步状态。</p>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">flutter in action</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, mahongquan.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.5.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/chapter10/turn_box.md.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>