
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>1.4 Dart语言简介 &#8212; Flutter in action  documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="dart">
<h1>1.4 Dart语言简介<a class="headerlink" href="#dart" title="Permalink to this headline">¶</a></h1>
<p>在之前我们已经介绍过Dart语言的相关特性，读者可以翻看一下，如果读者已经熟悉Dart语法，可以跳过本节，如果你还不了解Dart，也不用担心，按照笔者经验，如果你有过其他编程语言经验（尤其是Java和JavaScript）的话会非常容易上手Dart。当然，如果你是iOS开发者，也不用担心，Dart中也有一些与Swift比较相似的特性，如命名参数等，笔者当时学习Dart时，只是花了一个小时，看完Dart官网的Language Tour，就开始动手写Flutter了。</p>
<p>在笔者看来，Dart的设计目标应该是同时借鉴了Java和JavaScript。Dart在静态语法方面和Java非常相似，如类型定义、函数声明、泛型等，而在动态特性方面又和JavaScript很像，如函数式特性、异步支持等。除了融合Java和JavaScript语言之所长之外，Dart也具有一些其它具有表现力的语法，如可选命名参数、<code class="docutils literal notranslate"><span class="pre">..</span></code>（级联运算符）和<code class="docutils literal notranslate"><span class="pre">?.</span></code>（条件成员访问运算符）以及<code class="docutils literal notranslate"><span class="pre">??</span></code>（判空赋值运算符）。其实，对编程语言了解比较多的读者会发现，在Dart中其实看到的不仅有Java和JavaScript的影子，它还具有其它编程语言中的身影，如命名参数在Objective-C和Swift中早就很普遍，而<code class="docutils literal notranslate"><span class="pre">??</span></code>操作符在PHP 7.0语法中就已经存在了，因此我们可以看到Google对Dart语言给予厚望，是想把Dart打造成一门集百家之所长的编程语言。</p>
<p>接下来，我们先对Dart语法做一个简单的介绍，然后再将Dart与JavaScript和Java做一个简要的对比，方便读者更好的理解。</p>
<blockquote>
<div><p>注意：由于本书并非专门介绍Dart语言的书籍，所以本章主要会介绍一下在Flutter开发中常用的语法特性，如果想更多了解Dart，读者可以去Dart官网学习，现在互联网上Dart相关资料已经很多了。另外Dart 2.0已经正式发布，所以本书所有示例均采用Dart 2.0语法。</p>
</div></blockquote>
<div class="section" id="id1">
<h2>1.4.1 变量声明<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<ol>
<li><p><strong>var</strong></p>
<p>类似于JavaScript中的<code class="docutils literal notranslate"><span class="pre">var</span></code>，它可以接收任何类型的变量，但最大的不同是Dart中var变量一旦赋值，类型便会确定，则不能再改变其类型，如：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="n">t</span><span class="p">;</span>
<span class="n">t</span> <span class="o">=</span> <span class="s2">&quot;hi world&quot;</span><span class="p">;</span>
<span class="c1">// 下面代码在dart中会报错，因为变量t的类型已经确定为String，</span>
<span class="c1">// 类型一旦确定后则不能再更改其类型。</span>
<span class="n">t</span> <span class="o">=</span> <span class="m">1000</span><span class="p">;</span>
</pre></div>
</div>
<p>上面的代码在JavaScript是没有问题的，前端开发者需要注意一下，之所以有此差异是因为Dart本身是一个强类型语言，任何变量都是有确定类型的，在Dart中，当用<code class="docutils literal notranslate"><span class="pre">var</span></code>声明一个变量后，Dart在编译时会根据第一次赋值数据的类型来推断其类型，编译结束后其类型就已经被确定，而JavaScript是纯粹的弱类型脚本语言，var只是变量的声明方式而已。</p>
</li>
<li><p><strong>dynamic</strong>和<strong>Object</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">Object</span></code> 是Dart所有对象的根基类，也就是说所有类型都是<code class="docutils literal notranslate"><span class="pre">Object</span></code>的子类(包括Function和Null)，所以任何类型的数据都可以赋值给<code class="docutils literal notranslate"><span class="pre">Object</span></code>声明的对象.
<code class="docutils literal notranslate"><span class="pre">dynamic</span></code>与<code class="docutils literal notranslate"><span class="pre">var</span></code>一样都是关键词,声明的变量可以赋值任意对象。
而<code class="docutils literal notranslate"><span class="pre">dynamic</span></code>与<code class="docutils literal notranslate"><span class="pre">Object</span></code>相同之处在于,他们声明的变量可以在后期改变赋值类型。</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kt">dynamic</span> <span class="n">t</span><span class="p">;</span>
<span class="kt">Object</span> <span class="n">x</span><span class="p">;</span>
<span class="n">t</span> <span class="o">=</span> <span class="s2">&quot;hi world&quot;</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="s1">&#39;Hello Object&#39;</span><span class="p">;</span>
<span class="c1">//下面代码没有问题</span>
<span class="n">t</span> <span class="o">=</span> <span class="m">1000</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="m">1000</span><span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">dynamic</span></code>与<code class="docutils literal notranslate"><span class="pre">Object</span></code>不同的是,<code class="docutils literal notranslate"><span class="pre">dynamic</span></code>声明的对象编译器会提供所有可能的组合,
而<code class="docutils literal notranslate"><span class="pre">Object</span></code>声明的对象只能使用Object的属性与方法, 否则编译器会报错。如:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span> <span class="kt">dynamic</span> <span class="n">a</span><span class="p">;</span>
 <span class="kt">Object</span> <span class="n">b</span><span class="p">;</span>
 <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="n">a</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">;</span>
     <span class="n">b</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">;</span>
     <span class="n">printLengths</span><span class="p">();</span>
 <span class="p">}</span>   

 <span class="n">printLengths</span><span class="p">()</span> <span class="p">{</span>
     <span class="c1">// no warning</span>
     <span class="n">print</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
     <span class="c1">// warning:</span>
     <span class="c1">// The getter &#39;length&#39; is not defined for the class &#39;Object&#39;</span>
     <span class="n">print</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
 <span class="p">}</span>
</pre></div>
</div>
<p>变量a不会报错, 变量b编译器会报错</p>
<p><code class="docutils literal notranslate"><span class="pre">dynamic</span></code>的这个特性与<code class="docutils literal notranslate"><span class="pre">Objective-C</span></code>中的<code class="docutils literal notranslate"><span class="pre">id</span></code>作用很像.
<code class="docutils literal notranslate"><span class="pre">dynamic</span></code>的这个特点使得我们在使用它时需要格外注意,这很容易引入一个运行时错误.</p>
</li>
<li><p><strong>final</strong>和<strong>const</strong></p>
<p>如果您从未打算更改一个变量，那么使用 <code class="docutils literal notranslate"><span class="pre">final</span></code> 或 <code class="docutils literal notranslate"><span class="pre">const</span></code>，不是<code class="docutils literal notranslate"><span class="pre">var</span></code>，也不是一个类型。 一个 <code class="docutils literal notranslate"><span class="pre">final</span></code> 变量只能被设置一次，两者区别在于：<code class="docutils literal notranslate"><span class="pre">const</span></code> 变量是一个编译时常量，<code class="docutils literal notranslate"><span class="pre">final</span></code>变量在第一次使用时被初始化。被<code class="docutils literal notranslate"><span class="pre">final</span></code>或者<code class="docutils literal notranslate"><span class="pre">const</span></code>修饰的变量，变量类型可以省略，如：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="c1">//可以省略String这个类型声明</span>
<span class="kd">final</span> <span class="n">str</span> <span class="o">=</span> <span class="s2">&quot;hi world&quot;</span><span class="p">;</span>
<span class="c1">//final String str = &quot;hi world&quot;; </span>
<span class="k">const</span> <span class="n">str1</span> <span class="o">=</span> <span class="s2">&quot;hi world&quot;</span><span class="p">;</span>
<span class="c1">//const String str1 = &quot;hi world&quot;;</span>
</pre></div>
</div>
</li>
</ol>
</div>
<div class="section" id="id2">
<h2>1.4.2 函数<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>Dart是一种真正的面向对象的语言，所以即使是函数也是对象，并且有一个类型<strong>Function</strong>。这意味着函数可以赋值给变量或作为参数传递给其他函数，这是函数式编程的典型特征。</p>
<ol>
<li><p>函数声明</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">isNoble</span><span class="p">(</span><span class="kt">int</span> <span class="n">atomicNumber</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">_nobleGases</span><span class="p">[</span><span class="n">atomicNumber</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Dart函数声明如果没有显式声明返回值类型时会默认当做<code class="docutils literal notranslate"><span class="pre">dynamic</span></code>处理，注意，函数返回值没有类型推断：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kd">typedef</span> <span class="kt">bool</span> <span class="n">CALLBACK</span><span class="p">();</span>

<span class="c1">//不指定返回类型，此时默认为dynamic，不是bool</span>
<span class="n">isNoble</span><span class="p">(</span><span class="kt">int</span> <span class="n">atomicNumber</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">_nobleGases</span><span class="p">[</span><span class="n">atomicNumber</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">test</span><span class="p">(</span><span class="n">CALLBACK</span> <span class="n">cb</span><span class="p">){</span>
   <span class="n">print</span><span class="p">(</span><span class="n">cb</span><span class="p">());</span> 
<span class="p">}</span>
<span class="c1">//报错，isNoble不是bool类型</span>
<span class="n">test</span><span class="p">(</span><span class="n">isNoble</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p>对于只包含一个表达式的函数，可以使用简写语法</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span>bool isNoble (int atomicNumber)=&gt; _nobleGases [ atomicNumber ] ！= null ;   
</pre></div>
</div>
</li>
<li><p>函数作为变量</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="n">say</span> <span class="o">=</span> <span class="p">(</span><span class="n">str</span><span class="p">){</span>
  <span class="n">print</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
<span class="p">};</span>
<span class="n">say</span><span class="p">(</span><span class="s2">&quot;hi world&quot;</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p>函数作为参数传递</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">execute</span><span class="p">(</span><span class="kd">var</span> <span class="n">callback</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">callback</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">execute</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="n">print</span><span class="p">(</span><span class="s2">&quot;xxx&quot;</span><span class="p">))</span>
</pre></div>
</div>
</li>
<li><p>可选的位置参数</p>
<p>包装一组函数参数，用[]标记为可选的位置参数，并放在参数列表的最后面：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kt">String</span> <span class="n">say</span><span class="p">(</span><span class="kt">String</span> <span class="n">from</span><span class="p">,</span> <span class="kt">String</span> <span class="n">msg</span><span class="p">,</span> <span class="p">[</span><span class="kt">String</span> <span class="n">device</span><span class="p">])</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="n">result</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">$</span><span class="n">from</span><span class="s1"> says </span><span class="si">$</span><span class="n">msg</span><span class="s1">&#39;</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">device</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">result</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">$</span><span class="n">result</span><span class="s1"> with a </span><span class="si">$</span><span class="n">device</span><span class="s1">&#39;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>下面是一个不带可选参数调用这个函数的例子：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="n">say</span><span class="p">(</span><span class="s1">&#39;Bob&#39;</span><span class="p">,</span> <span class="s1">&#39;Howdy&#39;</span><span class="p">);</span> <span class="c1">//结果是： Bob says Howdy</span>
</pre></div>
</div>
<p>下面是用第三个参数调用这个函数的例子：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="n">say</span><span class="p">(</span><span class="s1">&#39;Bob&#39;</span><span class="p">,</span> <span class="s1">&#39;Howdy&#39;</span><span class="p">,</span> <span class="s1">&#39;smoke signal&#39;</span><span class="p">);</span> <span class="c1">//结果是：Bob says Howdy with a smoke signal</span>
</pre></div>
</div>
</li>
<li><p>可选的命名参数</p>
<p>定义函数时，使用{param1, param2, …}，放在参数列表的最后面，用于指定命名参数。例如：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="c1">//设置[bold]和[hidden]标志</span>
<span class="kt">void</span> <span class="n">enableFlags</span><span class="p">({</span><span class="kt">bool</span> <span class="n">bold</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">hidden</span><span class="p">})</span> <span class="p">{</span>
    <span class="c1">// ... </span>
<span class="p">}</span>
</pre></div>
</div>
<p>调用函数时，可以使用指定命名参数。例如：<code class="docutils literal notranslate"><span class="pre">paramName:</span> <span class="pre">value</span></code></p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="n">enableFlags</span><span class="p">(</span><span class="nl">bold:</span> <span class="kc">true</span><span class="p">,</span> <span class="nl">hidden:</span> <span class="kc">false</span><span class="p">);</span>
</pre></div>
</div>
<p>可选命名参数在Flutter中使用非常多。</p>
<p><strong>注意，不能同时使用可选的位置参数和可选的命名参数</strong></p>
</li>
</ol>
</div>
<div class="section" id="id3">
<h2>1.4.3 异步支持<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>Dart类库有非常多的返回<code class="docutils literal notranslate"><span class="pre">Future</span></code>或者<code class="docutils literal notranslate"><span class="pre">Stream</span></code>对象的函数。 这些函数被称为<strong>异步函数</strong>：它们只会在设置好一些耗时操作之后返回，比如像 IO操作。而不是等到这个操作完成。</p>
<p><code class="docutils literal notranslate"><span class="pre">async</span></code>和<code class="docutils literal notranslate"><span class="pre">await</span></code>关键词支持了异步编程，允许您写出和同步代码很像的异步代码。</p>
<div class="section" id="future">
<h3>Future<a class="headerlink" href="#future" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Future</span></code>与JavaScript中的<code class="docutils literal notranslate"><span class="pre">Promise</span></code>非常相似，表示一个异步操作的最终完成（或失败）及其结果值的表示。简单来说，它就是用于处理异步操作的，异步处理成功了就执行成功的操作，异步处理失败了就捕获错误或者停止后续操作。一个Future只会对应一个结果，要么成功，要么失败。</p>
<p>由于本身功能较多，这里我们只介绍其常用的API及特性。还有，请记住，<code class="docutils literal notranslate"><span class="pre">Future</span></code> 的所有API的返回值仍然是一个<code class="docutils literal notranslate"><span class="pre">Future</span></code>对象，所以可以很方便的进行链式调用。</p>
<div class="section" id="future-then">
<h4>Future.then<a class="headerlink" href="#future-then" title="Permalink to this headline">¶</a></h4>
<p>为了方便示例，在本例中我们使用<code class="docutils literal notranslate"><span class="pre">Future.delayed</span></code> 创建了一个延时任务（实际场景会是一个真正的耗时任务，比如一次网络请求），即2秒后返回结果字符串”hi world!”，然后我们在<code class="docutils literal notranslate"><span class="pre">then</span></code>中接收异步结果并打印结果，代码如下：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="n">Future</span><span class="p">.</span><span class="n">delayed</span><span class="p">(</span><span class="k">new</span> <span class="n">Duration</span><span class="p">(</span><span class="nl">seconds:</span> <span class="m">2</span><span class="p">),(){</span>
   <span class="k">return</span> <span class="s2">&quot;hi world!&quot;</span><span class="p">;</span>
<span class="p">}).</span><span class="n">then</span><span class="p">((</span><span class="n">data</span><span class="p">){</span>
   <span class="n">print</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
</div>
</div>
<div class="section" id="future-catcherror">
<h4>Future.catchError<a class="headerlink" href="#future-catcherror" title="Permalink to this headline">¶</a></h4>
<p>如果异步任务发生错误，我们可以在<code class="docutils literal notranslate"><span class="pre">catchError</span></code>中捕获错误，我们将上面示例改为：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="n">Future</span><span class="p">.</span><span class="n">delayed</span><span class="p">(</span><span class="k">new</span> <span class="n">Duration</span><span class="p">(</span><span class="nl">seconds:</span> <span class="m">2</span><span class="p">),(){</span>
   <span class="c1">//return &quot;hi world!&quot;;</span>
   <span class="k">throw</span> <span class="n">AssertionError</span><span class="p">(</span><span class="s2">&quot;Error&quot;</span><span class="p">);</span>  
<span class="p">}).</span><span class="n">then</span><span class="p">((</span><span class="n">data</span><span class="p">){</span>
   <span class="c1">//执行成功会走到这里  </span>
   <span class="n">print</span><span class="p">(</span><span class="s2">&quot;success&quot;</span><span class="p">);</span>
<span class="p">}).</span><span class="n">catchError</span><span class="p">((</span><span class="n">e</span><span class="p">){</span>
   <span class="c1">//执行失败会走到这里  </span>
   <span class="n">print</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
</div>
<p>在本示例中，我们在异步任务中抛出了一个异常，<code class="docutils literal notranslate"><span class="pre">then</span> </code>的回调函数将不会被执行，取而代之的是 <code class="docutils literal notranslate"><span class="pre">catchError</span></code>回调函数将被调用；但是，并不是只有 <code class="docutils literal notranslate"><span class="pre">catchError</span></code>回调才能捕获错误，<code class="docutils literal notranslate"><span class="pre">then</span></code>方法还有一个可选参数<code class="docutils literal notranslate"><span class="pre">onError</span></code>，我们也可以它来捕获异常：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="n">Future</span><span class="p">.</span><span class="n">delayed</span><span class="p">(</span><span class="k">new</span> <span class="n">Duration</span><span class="p">(</span><span class="nl">seconds:</span> <span class="m">2</span><span class="p">),</span> <span class="p">()</span> <span class="p">{</span>
	<span class="c1">//return &quot;hi world!&quot;;</span>
	<span class="k">throw</span> <span class="n">AssertionError</span><span class="p">(</span><span class="s2">&quot;Error&quot;</span><span class="p">);</span>
<span class="p">}).</span><span class="n">then</span><span class="p">((</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">print</span><span class="p">(</span><span class="s2">&quot;success&quot;</span><span class="p">);</span>
<span class="p">},</span> <span class="nl">onError:</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">print</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
</div>
</div>
<div class="section" id="future-whencomplete">
<h4>Future.whenComplete<a class="headerlink" href="#future-whencomplete" title="Permalink to this headline">¶</a></h4>
<p>有些时候，我们会遇到无论异步任务执行成功或失败都需要做一些事的场景，比如在网络请求前弹出加载对话框，在请求结束后关闭对话框。这种场景，有两种方法，第一种是分别在<code class="docutils literal notranslate"><span class="pre">then</span></code>或<code class="docutils literal notranslate"><span class="pre">catch</span></code>中关闭一下对话框，第二种就是使用<code class="docutils literal notranslate"><span class="pre">Future</span></code>的<code class="docutils literal notranslate"><span class="pre">whenComplete</span></code>回调，我们将上面示例改一下：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="n">Future</span><span class="p">.</span><span class="n">delayed</span><span class="p">(</span><span class="k">new</span> <span class="n">Duration</span><span class="p">(</span><span class="nl">seconds:</span> <span class="m">2</span><span class="p">),(){</span>
   <span class="c1">//return &quot;hi world!&quot;;</span>
   <span class="k">throw</span> <span class="n">AssertionError</span><span class="p">(</span><span class="s2">&quot;Error&quot;</span><span class="p">);</span>
<span class="p">}).</span><span class="n">then</span><span class="p">((</span><span class="n">data</span><span class="p">){</span>
   <span class="c1">//执行成功会走到这里 </span>
   <span class="n">print</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="p">}).</span><span class="n">catchError</span><span class="p">((</span><span class="n">e</span><span class="p">){</span>
   <span class="c1">//执行失败会走到这里   </span>
   <span class="n">print</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
<span class="p">}).</span><span class="n">whenComplete</span><span class="p">((){</span>
   <span class="c1">//无论成功或失败都会走到这里</span>
<span class="p">});</span>
</pre></div>
</div>
</div>
<div class="section" id="future-wait">
<h4>Future.wait<a class="headerlink" href="#future-wait" title="Permalink to this headline">¶</a></h4>
<p>有些时候，我们需要等待多个异步任务都执行结束后才进行一些操作，比如我们有一个界面，需要先分别从两个网络接口获取数据，获取成功后，我们需要将两个接口数据进行特定的处理后再显示到UI界面上，应该怎么做？答案是<code class="docutils literal notranslate"><span class="pre">Future.wait</span></code>，它接受一个<code class="docutils literal notranslate"><span class="pre">Future</span></code>数组参数，只有数组中所有<code class="docutils literal notranslate"><span class="pre">Future</span></code>都执行成功后，才会触发<code class="docutils literal notranslate"><span class="pre">then</span></code>的成功回调，只要有一个<code class="docutils literal notranslate"><span class="pre">Future</span></code>执行失败，就会触发错误回调。下面，我们通过模拟<code class="docutils literal notranslate"><span class="pre">Future.delayed</span></code> 来模拟两个数据获取的异步任务，等两个异步任务都执行成功时，将两个异步任务的结果拼接打印出来，代码如下：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="n">Future</span><span class="p">.</span><span class="n">wait</span><span class="p">([</span>
  <span class="c1">// 2秒后返回结果  </span>
  <span class="n">Future</span><span class="p">.</span><span class="n">delayed</span><span class="p">(</span><span class="k">new</span> <span class="n">Duration</span><span class="p">(</span><span class="nl">seconds:</span> <span class="m">2</span><span class="p">),</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s2">&quot;hello&quot;</span><span class="p">;</span>
  <span class="p">}),</span>
  <span class="c1">// 4秒后返回结果  </span>
  <span class="n">Future</span><span class="p">.</span><span class="n">delayed</span><span class="p">(</span><span class="k">new</span> <span class="n">Duration</span><span class="p">(</span><span class="nl">seconds:</span> <span class="m">4</span><span class="p">),</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s2">&quot; world&quot;</span><span class="p">;</span>
  <span class="p">})</span>
<span class="p">]).</span><span class="n">then</span><span class="p">((</span><span class="n">results</span><span class="p">){</span>
  <span class="n">print</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="o">+</span><span class="n">results</span><span class="p">[</span><span class="m">1</span><span class="p">]);</span>
<span class="p">}).</span><span class="n">catchError</span><span class="p">((</span><span class="n">e</span><span class="p">){</span>
  <span class="n">print</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
</div>
<p>执行上面代码，4秒后你会在控制台中看到“hello world”。</p>
</div>
</div>
<div class="section" id="async-await">
<h3>Async/await<a class="headerlink" href="#async-await" title="Permalink to this headline">¶</a></h3>
<p>Dart中的<code class="docutils literal notranslate"><span class="pre">async/await</span></code> 和JavaScript中的<code class="docutils literal notranslate"><span class="pre">async/await</span></code>功能和用法是一模一样的，如果你已经了解JavaScript中的<code class="docutils literal notranslate"><span class="pre">async/await</span></code>的用法，可以直接跳过本节。</p>
<div class="section" id="callback-hell">
<h4>回调地狱(Callback Hell)<a class="headerlink" href="#callback-hell" title="Permalink to this headline">¶</a></h4>
<p>如果代码中有大量异步逻辑，并且出现大量异步任务依赖其它异步任务的结果时，必然会出现<code class="docutils literal notranslate"><span class="pre">Future.then</span></code>回调中套回调情况。举个例子，比如现在有个需求场景是用户先登录，登录成功后会获得用户ID，然后通过用户ID，再去请求用户个人信息，获取到用户个人信息后，为了使用方便，我们需要将其缓存在本地文件系统，代码如下：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="c1">//先分别定义各个异步任务</span>
<span class="n">Future</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="n">login</span><span class="p">(</span><span class="kt">String</span> <span class="n">userName</span><span class="p">,</span> <span class="kt">String</span> <span class="n">pwd</span><span class="p">){</span>
	<span class="p">...</span>
    <span class="c1">//用户登录</span>
<span class="p">};</span>
<span class="n">Future</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="n">getUserInfo</span><span class="p">(</span><span class="kt">String</span> <span class="n">id</span><span class="p">){</span>
	<span class="p">...</span>
    <span class="c1">//获取用户信息 </span>
<span class="p">};</span>
<span class="n">Future</span> <span class="n">saveUserInfo</span><span class="p">(</span><span class="kt">String</span> <span class="n">userInfo</span><span class="p">){</span>
	<span class="p">...</span>
	<span class="c1">// 保存用户信息 </span>
<span class="p">};</span> 
</pre></div>
</div>
<p>接下来，执行整个任务流：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="n">login</span><span class="p">(</span><span class="s2">&quot;alice&quot;</span><span class="p">,</span><span class="s2">&quot;******&quot;</span><span class="p">).</span><span class="n">then</span><span class="p">((</span><span class="n">id</span><span class="p">){</span>
 <span class="c1">//登录成功后通过，id获取用户信息    </span>
 <span class="n">getUserInfo</span><span class="p">(</span><span class="n">id</span><span class="p">).</span><span class="n">then</span><span class="p">((</span><span class="n">userInfo</span><span class="p">){</span>
    <span class="c1">//获取用户信息后保存 </span>
    <span class="n">saveUserInfo</span><span class="p">(</span><span class="n">userInfo</span><span class="p">).</span><span class="n">then</span><span class="p">((){</span>
       <span class="c1">//保存用户信息，接下来执行其它操作</span>
        <span class="p">...</span>
    <span class="p">});</span>
  <span class="p">});</span>
<span class="p">})</span>
</pre></div>
</div>
<p>可以感受一下，如果业务逻辑中有大量异步依赖的情况，将会出现上面这种在回调里面套回调的情况，过多的嵌套会导致的代码可读性下降以及出错率提高，并且非常难维护，这个问题被形象的称为<strong>回调地狱（Callback Hell）</strong>。回调地狱问题在之前JavaScript中非常突出，也是JavaScript被吐槽最多的点，但随着ECMAScript6和ECMAScript7标准发布后，这个问题得到了非常好的解决，而解决回调地狱的两大神器正是ECMAScript6引入了<code class="docutils literal notranslate"><span class="pre">Promise</span></code>，以及ECMAScript7中引入的<code class="docutils literal notranslate"><span class="pre">async/await</span></code>。 而在Dart中几乎是完全平移了JavaScript中的这两者：<code class="docutils literal notranslate"><span class="pre">Future</span></code>相当于<code class="docutils literal notranslate"><span class="pre">Promise</span></code>，而<code class="docutils literal notranslate"><span class="pre">async/await</span></code>连名字都没改。接下来我们看看通过<code class="docutils literal notranslate"><span class="pre">Future</span></code>和<code class="docutils literal notranslate"><span class="pre">async/await</span></code>如何消除上面示例中的嵌套问题。</p>
<div class="section" id="futurecallback-hell">
<h5>使用Future消除Callback Hell<a class="headerlink" href="#futurecallback-hell" title="Permalink to this headline">¶</a></h5>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="n">login</span><span class="p">(</span><span class="s2">&quot;alice&quot;</span><span class="p">,</span><span class="s2">&quot;******&quot;</span><span class="p">).</span><span class="n">then</span><span class="p">((</span><span class="n">id</span><span class="p">){</span>
  	<span class="k">return</span> <span class="n">getUserInfo</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
<span class="p">}).</span><span class="n">then</span><span class="p">((</span><span class="n">userInfo</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">saveUserInfo</span><span class="p">(</span><span class="n">userInfo</span><span class="p">);</span>
<span class="p">}).</span><span class="n">then</span><span class="p">((</span><span class="n">e</span><span class="p">){</span>
   <span class="c1">//执行接下来的操作 </span>
<span class="p">}).</span><span class="n">catchError</span><span class="p">((</span><span class="n">e</span><span class="p">){</span>
  <span class="c1">//错误处理  </span>
  <span class="n">print</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
</div>
<p>正如上文所述， <em>“<code class="docutils literal notranslate"><span class="pre">Future</span></code> 的所有API的返回值仍然是一个<code class="docutils literal notranslate"><span class="pre">Future</span></code>对象，所以可以很方便的进行链式调用”</em> ，如果在then中返回的是一个<code class="docutils literal notranslate"><span class="pre">Future</span></code>的话，该<code class="docutils literal notranslate"><span class="pre">future</span></code>会执行，执行结束后会触发后面的<code class="docutils literal notranslate"><span class="pre">then</span></code>回调，这样依次向下，就避免了层层嵌套。</p>
</div>
<div class="section" id="async-awaitcallback-hell">
<h5>使用async/await消除callback hell<a class="headerlink" href="#async-awaitcallback-hell" title="Permalink to this headline">¶</a></h5>
<p>通过<code class="docutils literal notranslate"><span class="pre">Future</span></code>回调中再返回<code class="docutils literal notranslate"><span class="pre">Future</span></code>的方式虽然能避免层层嵌套，但是还是有一层回调，有没有一种方式能够让我们可以像写同步代码那样来执行异步任务而不使用回调的方式？答案是肯定的，这就要使用<code class="docutils literal notranslate"><span class="pre">async/await</span></code>了，下面我们先直接看代码，然后再解释，代码如下：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="n">task</span><span class="p">()</span> <span class="kd">async</span> <span class="p">{</span>
   <span class="k">try</span><span class="p">{</span>
    <span class="kt">String</span> <span class="n">id</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">login</span><span class="p">(</span><span class="s2">&quot;alice&quot;</span><span class="p">,</span><span class="s2">&quot;******&quot;</span><span class="p">);</span>
    <span class="kt">String</span> <span class="n">userInfo</span> <span class="o">=</span> <span class="kd">await</span> <span class="n">getUserInfo</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
    <span class="kd">await</span> <span class="n">saveUserInfo</span><span class="p">(</span><span class="n">userInfo</span><span class="p">);</span>
    <span class="c1">//执行接下来的操作   </span>
   <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="n">e</span><span class="p">){</span>
    <span class="c1">//错误处理   </span>
    <span class="n">print</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>   
   <span class="p">}</span>  
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">async</span></code>用来表示函数是异步的，定义的函数会返回一个<code class="docutils literal notranslate"><span class="pre">Future</span></code>对象，可以使用then方法添加回调函数。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">await</span></code> 后面是一个<code class="docutils literal notranslate"><span class="pre">Future</span></code>，表示等待该异步任务完成，异步完成后才会往下走；<code class="docutils literal notranslate"><span class="pre">await</span></code>必须出现在 <code class="docutils literal notranslate"><span class="pre">async</span></code> 函数内部。</p></li>
</ul>
<p>可以看到，我们通过<code class="docutils literal notranslate"><span class="pre">async/await</span></code>将一个异步流用同步的代码表示出来了。</p>
<blockquote>
<div><p>其实，无论是在JavaScript还是Dart中，<code class="docutils literal notranslate"><span class="pre">async/await</span></code>都只是一个语法糖，编译器或解释器最终都会将其转化为一个Promise（Future）的调用链。</p>
</div></blockquote>
</div>
</div>
</div>
</div>
<div class="section" id="stream">
<h2>1.4.4 Stream<a class="headerlink" href="#stream" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Stream</span></code> 也是用于接收异步事件数据，和<code class="docutils literal notranslate"><span class="pre">Future</span></code> 不同的是，它可以接收多个异步操作的结果（成功或失败）。 也就是说，在执行异步任务时，可以通过多次触发成功或失败事件来传递结果数据或错误异常。 <code class="docutils literal notranslate"><span class="pre">Stream</span></code> 常用于会多次读取数据的异步任务场景，如网络内容下载、文件读写等。举个例子：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="n">Stream</span><span class="p">.</span><span class="n">fromFutures</span><span class="p">([</span>
  <span class="c1">// 1秒后返回结果</span>
  <span class="n">Future</span><span class="p">.</span><span class="n">delayed</span><span class="p">(</span><span class="k">new</span> <span class="n">Duration</span><span class="p">(</span><span class="nl">seconds:</span> <span class="m">1</span><span class="p">),</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s2">&quot;hello 1&quot;</span><span class="p">;</span>
  <span class="p">}),</span>
  <span class="c1">// 抛出一个异常</span>
  <span class="n">Future</span><span class="p">.</span><span class="n">delayed</span><span class="p">(</span><span class="k">new</span> <span class="n">Duration</span><span class="p">(</span><span class="nl">seconds:</span> <span class="m">2</span><span class="p">),(){</span>
    <span class="k">throw</span> <span class="n">AssertionError</span><span class="p">(</span><span class="s2">&quot;Error&quot;</span><span class="p">);</span>
  <span class="p">}),</span>
  <span class="c1">// 3秒后返回结果</span>
  <span class="n">Future</span><span class="p">.</span><span class="n">delayed</span><span class="p">(</span><span class="k">new</span> <span class="n">Duration</span><span class="p">(</span><span class="nl">seconds:</span> <span class="m">3</span><span class="p">),</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s2">&quot;hello 3&quot;</span><span class="p">;</span>
  <span class="p">})</span>
<span class="p">]).</span><span class="n">listen</span><span class="p">((</span><span class="n">data</span><span class="p">){</span>
   <span class="n">print</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="p">},</span> <span class="nl">onError:</span> <span class="p">(</span><span class="n">e</span><span class="p">){</span>
   <span class="n">print</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">message</span><span class="p">);</span>
<span class="p">},</span><span class="nl">onDone:</span> <span class="p">(){</span>

<span class="p">});</span>
</pre></div>
</div>
<p>上面的代码依次会输出：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">I</span><span class="o">/</span><span class="n">flutter</span> <span class="p">(</span><span class="mi">17666</span><span class="p">):</span> <span class="n">hello</span> <span class="mi">1</span>
<span class="n">I</span><span class="o">/</span><span class="n">flutter</span> <span class="p">(</span><span class="mi">17666</span><span class="p">):</span> <span class="n">Error</span>
<span class="n">I</span><span class="o">/</span><span class="n">flutter</span> <span class="p">(</span><span class="mi">17666</span><span class="p">):</span> <span class="n">hello</span> <span class="mi">3</span>
</pre></div>
</div>
<p>代码很简单，就不赘述了。</p>
<blockquote>
<div><p>思考题：既然Stream可以接收多次事件，那能不能用Stream来实现一个订阅者模式的事件总线？</p>
</div></blockquote>
</div>
<div class="section" id="dartjavajavascript">
<h2>1.4.5 Dart和Java及JavaScript对比<a class="headerlink" href="#dartjavajavascript" title="Permalink to this headline">¶</a></h2>
<p>通过上面介绍，相信你对Dart应该有了一个初步的印象，由于笔者平时也使用Java和JavaScript，下面笔者根据自己的经验，结合Java和JavaScript，谈一下自己的看法。</p>
<blockquote>
<div><p>之所以将Dart与Java和JavaScript对比，是因为，这两者分别是强类型语言和弱类型语言的典型代表，并且Dart 语法中很多地方也都借鉴了Java和JavaScript。</p>
</div></blockquote>
<div class="section" id="dart-vs-java">
<h3>Dart vs Java<a class="headerlink" href="#dart-vs-java" title="Permalink to this headline">¶</a></h3>
<p>客观的来讲，Dart在语法层面确实比Java更有表现力；在VM层面，Dart VM在内存回收和吞吐量都进行了反复的优化，但具体的性能对比，笔者没有找到相关测试数据，但在笔者看来，只要Dart语言能流行，VM的性能就不用担心，毕竟Google在Go（没用VM但有GC）、JavaScript（v8）、Dalvik（Android上的Java VM）上已经有了很多技术积淀。值得注意的是Dart在Flutter中已经可以将GC做到10ms以内，所以Dart和Java相比，决胜因素并不会是在性能方面。而在语法层面，Dart要比Java更有表现力，最重要的是Dart对函数式编程支持要远强于Java(目前只停留在Lambda表达式)，而Dart目前真正的不足是<strong>生态</strong>，但笔者相信，随着Flutter的逐渐火热，会回过头来反推Dart生态加速发展，对于Dart来说，现在需要的是时间。</p>
</div>
<div class="section" id="dart-vs-javascript">
<h3>Dart vs JavaScript<a class="headerlink" href="#dart-vs-javascript" title="Permalink to this headline">¶</a></h3>
<p>JavaScript的弱类型一直被抓短，所以TypeScript、CoffeeScript甚至是Facebook的flow（虽然并不能算JavaScript的一个超集，但也通过标注和打包工具提供了静态类型检查）才有市场。就笔者使用过的脚本语言中（笔者曾使用过Python、PHP），JavaScript无疑是<strong>动态化</strong>支持最好的脚本语言，比如在JavaScript中，可以给任何对象在任何时候动态扩展属性，对于精通JavaScript的高手来说，这无疑是一把利剑。但是，任何事物都有两面性，JavaScript的强大的动态化特性也是把双刃剑，你可经常听到另一个声音，认为JavaScript的这种动态性糟糕透了，太过灵活反而导致代码很难预期，无法限制不被期望的修改。毕竟有些人总是对自己或别人写的代码不放心，他们希望能够让代码变得可控，并期望有一套静态类型检查系统来帮助自己减少错误。正因如此，在Flutter中，Dart几乎放弃了脚本语言动态化的特性，如不支持反射、也不支持动态创建函数等。并且Dart在2.0强制开启了类型检查（Strong Mode），原先的检查模式（checked mode）和可选类型（optional type）将淡出，所以在类型安全这个层面来说，Dart和TypeScript、CoffeeScript是差不多的，所以单从这一点来看，Dart并不具备什么明显优势，但综合起来看，Dart既能进行服务端脚本、APP开发、web开发，这就有优势了！</p>
<p>综上所述，笔者还是很看好Dart语言的将来，之所以表这个态，是因为在新技术发展初期，很多人可能还有所摇摆，有所犹豫，所以有必要给大家打一剂强心针，当然，这是一个见仁见智的问题，大家可以各抒己见。</p>
</div>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Flutter in action</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2014, Miguel Grinberg.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.5.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/chapter1/dart.md.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>