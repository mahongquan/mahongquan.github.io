
<!DOCTYPE html>

<html lang="zh-cn">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3.1 Widget简介 &#8212; flutter in action 1.0 documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="widget">
<h1>3.1 Widget简介<a class="headerlink" href="#widget" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2>3.1.1 概念<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>在前面的介绍中，我们知道在Flutter中几乎所有的对象都是一个Widget。与原生开发中“控件”不同的是，Flutter中的Widget的概念更广泛，它不仅可以表示UI元素，也可以表示一些功能性的组件如：用于手势检测的 <code class="docutils literal notranslate"><span class="pre">GestureDetector</span></code> widget、用于APP主题数据传递的<code class="docutils literal notranslate"><span class="pre">Theme</span></code>等等，而原生开发中的控件通常只是指UI元素。在后面的内容中，我们在描述UI元素时可能会用到“控件”、“组件”这样的概念，读者心里需要知道他们就是widget，只是在不同场景的不同表述而已。由于Flutter主要就是用于构建用户界面的，所以，在大多数时候，读者可以认为widget就是一个控件，不必纠结于概念。</p>
</div>
<div class="section" id="widgetelement">
<h2>3.1.2 Widget与Element<a class="headerlink" href="#widgetelement" title="Permalink to this headline">¶</a></h2>
<p>在Flutter中，Widget的功能是“描述一个UI元素的配置数据”，它就是说，Widget其实并不是表示最终绘制在设备屏幕上的显示元素，而它只是描述显示元素的一个配置数据。</p>
<p>实际上，Flutter中真正代表屏幕上显示元素的类是<code class="docutils literal notranslate"><span class="pre">Element</span></code>，也就是说Widget只是描述<code class="docutils literal notranslate"><span class="pre">Element</span></code>的配置数据！有关<code class="docutils literal notranslate"><span class="pre">Element</span></code>的详细介绍我们将在本书后面的高级部分深入介绍，现在，读者只需要知道：<strong>Widget只是UI元素的一个配置数据，并且一个Widget可以对应多个<code class="docutils literal notranslate"><span class="pre">Element</span></code></strong>。这是因为同一个Widget对象可以被添加到UI树的不同部分，而真正渲染时，UI树的每一个<code class="docutils literal notranslate"><span class="pre">Element</span></code>节点都会对应一个Widget对象。总结一下：</p>
<ul class="simple">
<li><p>Widget实际上就是<code class="docutils literal notranslate"><span class="pre">Element</span></code>的配置数据，Widget树实际上是一个配置树，而真正的UI渲染树是由<code class="docutils literal notranslate"><span class="pre">Element</span></code>构成；不过，由于<code class="docutils literal notranslate"><span class="pre">Element</span></code>是通过Widget生成的，所以它们之间有对应关系，在大多数场景，我们可以宽泛地认为Widget树就是指UI控件树或UI渲染树。</p></li>
<li><p>一个Widget对象可以对应多个<code class="docutils literal notranslate"><span class="pre">Element</span></code>对象。这很好理解，根据同一份配置（Widget），可以创建多个实例（Element）。</p></li>
</ul>
<p>读者应该将这两点牢记在心中。</p>
</div>
<div class="section" id="id2">
<h2>3.1.3 Widget主要接口<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>我们先来看一下Widget类的声明：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span>@immutable
abstract class Widget extends DiagnosticableTree {
  const Widget({ this.key });
  final Key key;
    
  @protected
  Element createElement();

  @override
  String toStringShort() {
    return key == null ? &#39;$runtimeType&#39; : &#39;$runtimeType-$key&#39;;
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.defaultDiagnosticsTreeStyle = DiagnosticsTreeStyle.dense;
  }
  
  static bool canUpdate(Widget oldWidget, Widget newWidget) {
    return oldWidget.runtimeType == newWidget.runtimeType
        &amp;&amp; oldWidget.key == newWidget.key;
  }
}
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Widget</span></code>类继承自<code class="docutils literal notranslate"><span class="pre">DiagnosticableTree</span></code>，<code class="docutils literal notranslate"><span class="pre">DiagnosticableTree</span></code>即“诊断树”，主要作用是提供调试信息。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Key</span></code>: 这个<code class="docutils literal notranslate"><span class="pre">key</span></code>属性类似于React/Vue中的<code class="docutils literal notranslate"><span class="pre">key</span></code>，主要的作用是决定是否在下一次<code class="docutils literal notranslate"><span class="pre">build</span></code>时复用旧的widget，决定的条件在<code class="docutils literal notranslate"><span class="pre">canUpdate()</span></code>方法中。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">createElement()</span></code>：正如前文所述“一个Widget可以对应多个<code class="docutils literal notranslate"><span class="pre">Element</span></code>”；Flutter Framework在构建UI树时，会先调用此方法生成对应节点的<code class="docutils literal notranslate"><span class="pre">Element</span></code>对象。此方法是Flutter Framework隐式调用的，在我们开发过程中基本不会调用到。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">debugFillProperties(...)</span></code> 复写父类的方法，主要是设置诊断树的一些特性。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">canUpdate(...)</span></code>是一个静态方法，它主要用于在Widget树重新<code class="docutils literal notranslate"><span class="pre">build</span></code>时复用旧的widget，其实具体来说，应该是：是否用新的Widget对象去更新旧UI树上所对应的<code class="docutils literal notranslate"><span class="pre">Element</span></code>对象的配置；通过其源码我们可以看到，只要<code class="docutils literal notranslate"><span class="pre">newWidget</span></code>与<code class="docutils literal notranslate"><span class="pre">oldWidget</span></code>的<code class="docutils literal notranslate"><span class="pre">runtimeType</span></code>和<code class="docutils literal notranslate"><span class="pre">key</span></code>同时相等时就会用<code class="docutils literal notranslate"><span class="pre">newWidget</span></code>去更新<code class="docutils literal notranslate"><span class="pre">Element</span></code>对象的配置，否则就会创建新的<code class="docutils literal notranslate"><span class="pre">Element</span></code>。</p></li>
</ul>
<p>有关Key和Widget复用的细节将会在本书后面高级部分深入讨论，读者现在只需知道，为Widget显式添加key的话可能（但不一定）会使UI在重新构建时变的高效，读者目前可以先忽略此参数。本书后面的示例中，只会在构建列表项UI时会显式指定Key。</p>
<p>另外<code class="docutils literal notranslate"><span class="pre">Widget</span></code>类本身是一个抽象类，其中最核心的就是定义了<code class="docutils literal notranslate"><span class="pre">createElement()</span></code>接口，在Flutter开发中，我们一般都不用直接继承<code class="docutils literal notranslate"><span class="pre">Widget</span></code>类来实现一个新组件，相反，我们通常会通过继承<code class="docutils literal notranslate"><span class="pre">StatelessWidget</span></code>或<code class="docutils literal notranslate"><span class="pre">StatefulWidget</span></code>来间接继承<code class="docutils literal notranslate"><span class="pre">Widget</span></code>类来实现。<code class="docutils literal notranslate"><span class="pre">StatelessWidget</span></code>和<code class="docutils literal notranslate"><span class="pre">StatefulWidget</span></code>都是直接继承自<code class="docutils literal notranslate"><span class="pre">Widget</span></code>类，而这两个类也正是Flutter中非常重要的两个抽象类，它们引入了两种Widget模型，接下来我们将重点介绍一下这两个类。</p>
</div>
<div class="section" id="statelesswidget">
<h2>3.1.4 StatelessWidget<a class="headerlink" href="#statelesswidget" title="Permalink to this headline">¶</a></h2>
<p>在之前的章节中，我们已经简单介绍过<code class="docutils literal notranslate"><span class="pre">StatelessWidget</span></code>，<code class="docutils literal notranslate"><span class="pre">StatelessWidget</span></code>相对比较简单，它继承自<code class="docutils literal notranslate"><span class="pre">Widget</span></code>类，重写了<code class="docutils literal notranslate"><span class="pre">createElement()</span> </code>方法：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span>@override
StatelessElement createElement() =&gt; new StatelessElement(this);
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">StatelessElement</span></code> 间接继承自<code class="docutils literal notranslate"><span class="pre">Element</span></code>类，与<code class="docutils literal notranslate"><span class="pre">StatelessWidget</span></code>相对应（作为其配置数据）。</p>
<p><code class="docutils literal notranslate"><span class="pre">StatelessWidget</span></code>用于不需要维护状态的场景，它通常在<code class="docutils literal notranslate"><span class="pre">build</span></code>方法中通过嵌套其它Widget来构建UI，在构建过程中会递归的构建其嵌套的Widget。我们看一个简单的例子：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span>class Echo extends StatelessWidget {
  const Echo({
    Key key,  
    @required this.text,
    this.backgroundColor:Colors.grey,
  }):super(key:key);
    
  final String text;
  final Color backgroundColor;

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Container(
        color: backgroundColor,
        child: Text(text),
      ),
    );
  }
}
</pre></div>
</div>
<p>上面的代码，实现了一个回显字符串的<code class="docutils literal notranslate"><span class="pre">Echo</span></code> widget。</p>
<blockquote>
<div><p>按照惯例，<code class="docutils literal notranslate"><span class="pre">widget</span></code>的构造函数参数应使用命名参数，命名参数中的必要参数要添加<code class="docutils literal notranslate"><span class="pre">&#64;required</span></code>标注，这样有利于静态代码分析器进行检查。另外，在继承<code class="docutils literal notranslate"><span class="pre">widget</span></code>时，第一个参数通常应该是<code class="docutils literal notranslate"><span class="pre">Key</span></code>，另外，如果Widget需要接收子Widget，那么<code class="docutils literal notranslate"><span class="pre">child</span></code>或<code class="docutils literal notranslate"><span class="pre">children</span></code>参数通常应被放在参数列表的最后。同样是按照惯例，Widget的属性应尽可能的被声明为<code class="docutils literal notranslate"><span class="pre">final</span></code>，防止被意外改变。</p>
</div></blockquote>
<p>然后我们可以通过如下方式使用它：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="n">Widget</span> <span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">Echo</span><span class="p">(</span><span class="nl">text:</span> <span class="s2">&quot;hello world&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>运行后效果如图3-1所示：</p>
<p><img alt="图3-1" src="../_images/3-1.png" /></p>
<div class="section" id="context">
<h3>Context<a class="headerlink" href="#context" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">build</span></code>方法有一个<code class="docutils literal notranslate"><span class="pre">context</span></code>参数，它是<code class="docutils literal notranslate"><span class="pre">BuildContext</span></code>类的一个实例，表示当前widget在widget树中的上下文，每一个widget都会对应一个context对象（因为每一个widget都是widget树上的一个节点）。实际上，<code class="docutils literal notranslate"><span class="pre">context</span></code>是当前widget在widget树中位置中执行”相关操作“的一个句柄，比如它提供了从当前widget开始向上遍历widget树以及按照widget类型查找父级widget的方法。下面是在子树中获取父级widget的一个示例：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span>class ContextRoute extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(&quot;Context测试&quot;),
      ),
      body: Container(
        child: Builder(builder: (context) {
          // 在Widget树中向上查找最近的父级`Scaffold` widget
          Scaffold scaffold = context.findAncestorWidgetOfExactType&lt;Scaffold&gt;();
          // 直接返回 AppBar的title， 此处实际上是Text(&quot;Context测试&quot;)
          return (scaffold.appBar as AppBar).title;
        }),
      ),
    );
  }
}
</pre></div>
</div>
<p>运行后效果如图3-1-1所示：</p>
<p><img alt="图3-1-1" src="../_images/3-1-1.png" /></p>
<blockquote>
<div><p><strong>注意</strong>：对于<code class="docutils literal notranslate"><span class="pre">BuildContext</span></code>读者现在可以先作了解，随着本书后面内容的展开，也会用到Context的一些方法，读者可以通过具体的场景对其有个直观的认识。关于<code class="docutils literal notranslate"><span class="pre">BuildContext</span></code>更多的内容，我们也将在后面高级部分再深入介绍。</p>
</div></blockquote>
</div>
</div>
<div class="section" id="statefulwidget">
<h2>3.1.5 StatefulWidget<a class="headerlink" href="#statefulwidget" title="Permalink to this headline">¶</a></h2>
<p>和<code class="docutils literal notranslate"><span class="pre">StatelessWidget</span></code>一样，<code class="docutils literal notranslate"><span class="pre">StatefulWidget</span></code>也是继承自<code class="docutils literal notranslate"><span class="pre">Widget</span></code>类，并重写了<code class="docutils literal notranslate"><span class="pre">createElement()</span> </code>方法，不同的是返回的<code class="docutils literal notranslate"><span class="pre">Element</span></code> 对象并不相同；另外<code class="docutils literal notranslate"><span class="pre">StatefulWidget</span></code>类中添加了一个新的接口<code class="docutils literal notranslate"><span class="pre">createState()</span></code>。</p>
<p>下面我们看看<code class="docutils literal notranslate"><span class="pre">StatefulWidget</span></code>的类定义：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span>abstract class StatefulWidget extends Widget {
  const StatefulWidget({ Key key }) : super(key: key);
    
  @override
  StatefulElement createElement() =&gt; new StatefulElement(this);
    
  @protected
  State createState();
}
</pre></div>
</div>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">StatefulElement</span> </code> 间接继承自<code class="docutils literal notranslate"><span class="pre">Element</span></code>类，与StatefulWidget相对应（作为其配置数据）。<code class="docutils literal notranslate"><span class="pre">StatefulElement</span> </code>中可能会多次调用<code class="docutils literal notranslate"><span class="pre">createState()</span></code>来创建状态(State)对象。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">createState()</span></code> 用于创建和Stateful widget相关的状态，它在Stateful widget的生命周期中可能会被多次调用。例如，当一个Stateful widget同时插入到widget树的多个位置时，Flutter framework就会调用该方法为每一个位置生成一个独立的State实例，其实，本质上就是一个<code class="docutils literal notranslate"><span class="pre">StatefulElement</span></code>对应一个State实例。</p>
<blockquote>
<div><p>在本书中经常会出现“树”的概念，在不同的场景可能指不同的意思，在说“widget树”时它可以指widget结构树，但由于widget与Element有对应关系（一可能对多），在有些场景（Flutter的SDK文档中）也代指“UI树”的意思。而在stateful widget中，State对象也和<code class="docutils literal notranslate"><span class="pre">StatefulElement</span></code>具有对应关系（一对一），所以在Flutter的SDK文档中，可以经常看到“从树中移除State对象”或“插入State对象到树中”这样的描述。其实，无论哪种描述，其意思都是在描述“一棵构成用户界面的节点元素的树”，读者不必纠结于这些概念，还是那句话“得其神，忘其形”，因此，本书中出现的各种“树”，如果没有特别说明，读者都可抽象的认为它是“一棵构成用户界面的节点元素的树”。</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="state">
<h2>3.1.6 State<a class="headerlink" href="#state" title="Permalink to this headline">¶</a></h2>
<p>一个StatefulWidget类会对应一个State类，State表示与其对应的StatefulWidget要维护的状态，State中的保存的状态信息可以：</p>
<ol class="simple">
<li><p>在widget 构建时可以被同步读取。</p></li>
<li><p>在widget生命周期中可以被改变，当State被改变时，可以手动调用其<code class="docutils literal notranslate"><span class="pre">setState()</span></code>方法通知Flutter framework状态发生改变，Flutter framework在收到消息后，会重新调用其<code class="docutils literal notranslate"><span class="pre">build</span></code>方法重新构建widget树，从而达到更新UI的目的。</p></li>
</ol>
<p>State中有两个常用属性：</p>
<ol class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">widget</span></code>，它表示与该State实例关联的widget实例，由Flutter framework动态设置。注意，这种关联并非永久的，因为在应用生命周期中，UI树上的某一个节点的widget实例在重新构建时可能会变化，但State实例只会在第一次插入到树中时被创建，当在重新构建时，如果widget被修改了，Flutter framework会动态设置State.widget为新的widget实例。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">context</span></code>。StatefulWidget对应的BuildContext，作用同StatelessWidget的BuildContext。</p></li>
</ol>
<div class="section" id="id3">
<h3>State生命周期<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>理解State的生命周期对flutter开发非常重要，为了加深读者印象，本节我们通过一个实例来演示一下State的生命周期。在接下来的示例中，我们实现一个计数器widget，点击它可以使计数器加1，由于要保存计数器的数值状态，所以我们应继承StatefulWidget，代码如下：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span>class CounterWidget extends StatefulWidget {
  const CounterWidget({
    Key key,
    this.initValue: 0
  });

  final int initValue;

  @override
  _CounterWidgetState createState() =&gt; new _CounterWidgetState();
}
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">CounterWidget</span></code>接收一个<code class="docutils literal notranslate"><span class="pre">initValue</span></code>整型参数，它表示计数器的初始值。下面我们看一下State的代码：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span>class _CounterWidgetState extends State&lt;CounterWidget&gt; {  
  int _counter;

  @override
  void initState() {
    super.initState();
    //初始化状态  
    _counter=widget.initValue;
    print(&quot;initState&quot;);
  }

  @override
  Widget build(BuildContext context) {
    print(&quot;build&quot;);
    return Scaffold(
      body: Center(
        child: FlatButton(
          child: Text(&#39;$_counter&#39;),
          //点击后计数器自增
          onPressed:()=&gt;setState(()=&gt; ++_counter,
          ),
        ),
      ),
    );
  }

  @override
  void didUpdateWidget(CounterWidget oldWidget) {
    super.didUpdateWidget(oldWidget);
    print(&quot;didUpdateWidget&quot;);
  }

  @override
  void deactivate() {
    super.deactivate();
    print(&quot;deactive&quot;);
  }

  @override
  void dispose() {
    super.dispose();
    print(&quot;dispose&quot;);
  }

  @override
  void reassemble() {
    super.reassemble();
    print(&quot;reassemble&quot;);
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    print(&quot;didChangeDependencies&quot;);
  }

}
</pre></div>
</div>
<p>接下来，我们创建一个新路由，在新路由中，我们只显示一个<code class="docutils literal notranslate"><span class="pre">CounterWidget</span></code>：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="n">Widget</span> <span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">CounterWidget</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>我们运行应用并打开该路由页面，在新路由页打开后，屏幕中央就会出现一个数字0，然后控制台日志输出：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">I</span><span class="o">/</span><span class="n">flutter</span> <span class="p">(</span> <span class="mi">5436</span><span class="p">):</span> <span class="n">initState</span>
<span class="n">I</span><span class="o">/</span><span class="n">flutter</span> <span class="p">(</span> <span class="mi">5436</span><span class="p">):</span> <span class="n">didChangeDependencies</span>
<span class="n">I</span><span class="o">/</span><span class="n">flutter</span> <span class="p">(</span> <span class="mi">5436</span><span class="p">):</span> <span class="n">build</span>
</pre></div>
</div>
<p>可以看到，在StatefulWidget插入到Widget树时首先<code class="docutils literal notranslate"><span class="pre">initState</span></code>方法会被调用。</p>
<p>然后我们点击⚡️按钮热重载，控制台输出日志如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">I</span><span class="o">/</span><span class="n">flutter</span> <span class="p">(</span> <span class="mi">5436</span><span class="p">):</span> <span class="n">reassemble</span>
<span class="n">I</span><span class="o">/</span><span class="n">flutter</span> <span class="p">(</span> <span class="mi">5436</span><span class="p">):</span> <span class="n">didUpdateWidget</span>
<span class="n">I</span><span class="o">/</span><span class="n">flutter</span> <span class="p">(</span> <span class="mi">5436</span><span class="p">):</span> <span class="n">build</span>
</pre></div>
</div>
<p>可以看到此时<code class="docutils literal notranslate"> <span class="pre">initState</span></code> 和<code class="docutils literal notranslate"><span class="pre">didChangeDependencies</span></code>都没有被调用，而此时<code class="docutils literal notranslate"><span class="pre">didUpdateWidget</span></code>被调用。</p>
<p>接下来，我们在widget树中移除<code class="docutils literal notranslate"><span class="pre">CounterWidget</span></code>，将路由<code class="docutils literal notranslate"><span class="pre">build</span></code>方法改为：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="n">Widget</span> <span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">//移除计数器 </span>
  <span class="c1">//return CounterWidget();</span>
  <span class="c1">//随便返回一个Text()</span>
  <span class="k">return</span> <span class="n">Text</span><span class="p">(</span><span class="s2">&quot;xxx&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>然后热重载，日志如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">I</span><span class="o">/</span><span class="n">flutter</span> <span class="p">(</span> <span class="mi">5436</span><span class="p">):</span> <span class="n">reassemble</span>
<span class="n">I</span><span class="o">/</span><span class="n">flutter</span> <span class="p">(</span> <span class="mi">5436</span><span class="p">):</span> <span class="n">deactive</span>
<span class="n">I</span><span class="o">/</span><span class="n">flutter</span> <span class="p">(</span> <span class="mi">5436</span><span class="p">):</span> <span class="n">dispose</span>
</pre></div>
</div>
<p>我们可以看到，在<code class="docutils literal notranslate"><span class="pre">CounterWidget</span></code>从widget树中移除时，<code class="docutils literal notranslate"><span class="pre">deactive</span></code>和<code class="docutils literal notranslate"><span class="pre">dispose</span></code>会依次被调用。</p>
<p>下面我们来看看各个回调函数：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">initState</span></code>：当Widget第一次插入到Widget树时会被调用，对于每一个State对象，Flutter framework只会调用一次该回调，所以，通常在该回调中做一些一次性的操作，如状态初始化、订阅子树的事件通知等。不能在该回调中调用<code class="docutils literal notranslate"><span class="pre">BuildContext.dependOnInheritedWidgetOfExactType</span></code>（该方法用于在Widget树上获取离当前widget最近的一个父级<code class="docutils literal notranslate"><span class="pre">InheritFromWidget</span></code>，关于<code class="docutils literal notranslate"><span class="pre">InheritedWidget</span></code>我们将在后面章节介绍），原因是在初始化完成后，Widget树中的<code class="docutils literal notranslate"><span class="pre">InheritFromWidget</span></code>也可能会发生变化，所以正确的做法应该在在<code class="docutils literal notranslate"><span class="pre">build（）</span></code>方法或<code class="docutils literal notranslate"><span class="pre">didChangeDependencies()</span></code>中调用它。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">didChangeDependencies()</span></code>：当State对象的依赖发生变化时会被调用；例如：在之前<code class="docutils literal notranslate"><span class="pre">build()</span></code> 中包含了一个<code class="docutils literal notranslate"><span class="pre">InheritedWidget</span></code>，然后在之后的<code class="docutils literal notranslate"><span class="pre">build()</span></code> 中<code class="docutils literal notranslate"><span class="pre">InheritedWidget</span></code>发生了变化，那么此时<code class="docutils literal notranslate"><span class="pre">InheritedWidget</span></code>的子widget的<code class="docutils literal notranslate"><span class="pre">didChangeDependencies()</span></code>回调都会被调用。典型的场景是当系统语言Locale或应用主题改变时，Flutter framework会通知widget调用此回调。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">build()</span></code>：此回调读者现在应该已经相当熟悉了，它主要是用于构建Widget子树的，会在如下场景被调用：</p>
<ol class="simple">
<li><p>在调用<code class="docutils literal notranslate"><span class="pre">initState()</span></code>之后。</p></li>
<li><p>在调用<code class="docutils literal notranslate"><span class="pre">didUpdateWidget()</span></code>之后。</p></li>
<li><p>在调用<code class="docutils literal notranslate"><span class="pre">setState()</span></code>之后。</p></li>
<li><p>在调用<code class="docutils literal notranslate"><span class="pre">didChangeDependencies()</span></code>之后。</p></li>
<li><p>在State对象从树中一个位置移除后（会调用deactivate）又重新插入到树的其它位置之后。</p></li>
</ol>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">reassemble()</span></code>：此回调是专门为了开发调试而提供的，在热重载(hot reload)时会被调用，此回调在Release模式下永远不会被调用。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">didUpdateWidget()</span></code>：在widget重新构建时，Flutter framework会调用<code class="docutils literal notranslate"><span class="pre">Widget.canUpdate</span></code>来检测Widget树中同一位置的新旧节点，然后决定是否需要更新，如果<code class="docutils literal notranslate"><span class="pre">Widget.canUpdate</span></code>返回<code class="docutils literal notranslate"><span class="pre">true</span></code>则会调用此回调。正如之前所述，<code class="docutils literal notranslate"><span class="pre">Widget.canUpdate</span></code>会在新旧widget的key和runtimeType同时相等时会返回true，也就是说在在新旧widget的key和runtimeType同时相等时<code class="docutils literal notranslate"><span class="pre">didUpdateWidget()</span></code>就会被调用。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">deactivate()</span></code>：当State对象从树中被移除时，会调用此回调。在一些场景下，Flutter framework会将State对象重新插到树中，如包含此State对象的子树在树的一个位置移动到另一个位置时（可以通过GlobalKey来实现）。如果移除后没有重新插入到树中则紧接着会调用<code class="docutils literal notranslate"><span class="pre">dispose()</span></code>方法。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dispose()</span></code>：当State对象从树中被永久移除时调用；通常在此回调中释放资源。</p></li>
</ul>
<p>StatefulWidget生命周期如图3-2所示：</p>
<p><img alt="图3-2" src="../_images/3-2.jpg" /></p>
<blockquote>
<div><p><strong>注意</strong>：在继承<code class="docutils literal notranslate"><span class="pre">StatefulWidget</span></code>重写其方法时，对于包含<code class="docutils literal notranslate"><span class="pre">&#64;mustCallSuper</span></code>标注的父类方法，都要在子类方法中先调用父类方法。</p>
</div></blockquote>
</div>
<div class="section" id="buildstate-statefulwidget">
<h3>为什么要将build方法放在State中，而不是放在StatefulWidget中？<a class="headerlink" href="#buildstate-statefulwidget" title="Permalink to this headline">¶</a></h3>
<p>现在，我们回答之前提出的问题，为什么<code class="docutils literal notranslate"><span class="pre">build()</span></code>方法放在State（而不是<code class="docutils literal notranslate"><span class="pre">StatefulWidget</span></code>）中 ？这主要是为了提高开发的灵活性。如果将<code class="docutils literal notranslate"><span class="pre">build()</span></code>方法在<code class="docutils literal notranslate"><span class="pre">StatefulWidget</span></code>中则会有两个问题：</p>
<ul>
<li><p>状态访问不便。</p>
<p>试想一下，如果我们的<code class="docutils literal notranslate"><span class="pre">StatefulWidget</span></code>有很多状态，而每次状态改变都要调用<code class="docutils literal notranslate"><span class="pre">build</span></code>方法，由于状态是保存在State中的，如果<code class="docutils literal notranslate"><span class="pre">build</span></code>方法在<code class="docutils literal notranslate"><span class="pre">StatefulWidget</span></code>中，那么<code class="docutils literal notranslate"><span class="pre">build</span></code>方法和状态分别在两个类中，那么构建时读取状态将会很不方便！试想一下，如果真的将<code class="docutils literal notranslate"><span class="pre">build</span></code>方法放在StatefulWidget中的话，由于构建用户界面过程需要依赖State，所以<code class="docutils literal notranslate"><span class="pre">build</span></code>方法将必须加一个<code class="docutils literal notranslate"><span class="pre">State</span></code>参数，大概是下面这样：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span>  <span class="n">Widget</span> <span class="n">build</span><span class="p">(</span><span class="n">BuildContext</span> <span class="n">context</span><span class="p">,</span> <span class="n">State</span> <span class="n">state</span><span class="p">){</span>
      <span class="c1">//state.counter</span>
      <span class="p">...</span>
  <span class="p">}</span>
</pre></div>
</div>
<p>这样的话就只能将State的所有状态声明为公开的状态，这样才能在State类外部访问状态！但是，将状态设置为公开后，状态将不再具有私密性，这就会导致对状态的修改将会变的不可控。但如果将<code class="docutils literal notranslate"><span class="pre">build()</span></code>方法放在State中的话，构建过程不仅可以直接访问状态，而且也无需公开私有状态，这会非常方便。</p>
</li>
<li><p>继承<code class="docutils literal notranslate"><span class="pre">StatefulWidget</span></code>不便。</p>
<p>例如，Flutter中有一个动画widget的基类<code class="docutils literal notranslate"><span class="pre">AnimatedWidget</span></code>，它继承自<code class="docutils literal notranslate"><span class="pre">StatefulWidget</span></code>类。<code class="docutils literal notranslate"><span class="pre">AnimatedWidget</span></code>中引入了一个抽象方法<code class="docutils literal notranslate"><span class="pre">build(BuildContext</span> <span class="pre">context)</span></code>，继承自<code class="docutils literal notranslate"><span class="pre">AnimatedWidget</span></code>的动画widget都要实现这个<code class="docutils literal notranslate"><span class="pre">build</span></code>方法。现在设想一下，如果<code class="docutils literal notranslate"><span class="pre">StatefulWidget</span></code> 类中已经有了一个<code class="docutils literal notranslate"><span class="pre">build</span></code>方法，正如上面所述，此时<code class="docutils literal notranslate"><span class="pre">build</span></code>方法需要接收一个state对象，这就意味着<code class="docutils literal notranslate"><span class="pre">AnimatedWidget</span></code>必须将自己的State对象(记为_animatedWidgetState)提供给其子类，因为子类需要在其<code class="docutils literal notranslate"><span class="pre">build</span></code>方法中调用父类的<code class="docutils literal notranslate"><span class="pre">build</span></code>方法，代码可能如下：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span>class MyAnimationWidget extends AnimatedWidget{
    @override
    Widget build(BuildContext context, State state){
      //由于子类要用到AnimatedWidget的状态对象_animatedWidgetState，
      //所以AnimatedWidget必须通过某种方式将其状态对象_animatedWidgetState
      //暴露给其子类   
      super.build(context, _animatedWidgetState)
    }
}
</pre></div>
</div>
<p>这样很显然是不合理的，因为</p>
<ol class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">AnimatedWidget</span></code>的状态对象是<code class="docutils literal notranslate"><span class="pre">AnimatedWidget</span></code>内部实现细节，不应该暴露给外部。</p></li>
<li><p>如果要将父类状态暴露给子类，那么必须得有一种传递机制，而做这一套传递机制是无意义的，因为父子类之间状态的传递和子类本身逻辑是无关的。</p></li>
</ol>
</li>
</ul>
<p>综上所述，可以发现，对于<code class="docutils literal notranslate"><span class="pre">StatefulWidget</span></code>，将<code class="docutils literal notranslate"><span class="pre">build</span></code>方法放在State中，可以给开发带来很大的灵活性。</p>
</div>
</div>
<div class="section" id="widgetstate">
<h2>3.1.7 在Widget树中获取State对象<a class="headerlink" href="#widgetstate" title="Permalink to this headline">¶</a></h2>
<p>由于StatefulWidget的的具体逻辑都在其State中，所以很多时候，我们需要获取StatefulWidget对应的State对象来调用一些方法，比如<code class="docutils literal notranslate"><span class="pre">Scaffold</span></code>组件对应的状态类<code class="docutils literal notranslate"><span class="pre">ScaffoldState</span></code>中就定义了打开SnackBar(路由页底部提示条)的方法。我们有两种方法在子widget树中获取父级StatefulWidget的State对象。</p>
<div class="section" id="id4">
<h3>通过Context获取<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">context</span></code>对象有一个<code class="docutils literal notranslate"><span class="pre">findAncestorStateOfType()</span></code>方法，该方法可以从当前节点沿着widget树向上查找指定类型的StatefulWidget对应的State对象。下面是实现打开SnackBar的示例：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="n">Scaffold</span><span class="p">(</span>
  <span class="nl">appBar:</span> <span class="n">AppBar</span><span class="p">(</span>
    <span class="nl">title:</span> <span class="n">Text</span><span class="p">(</span><span class="s2">&quot;子树中获取State对象&quot;</span><span class="p">),</span>
  <span class="p">),</span>
  <span class="nl">body:</span> <span class="n">Center</span><span class="p">(</span>
    <span class="nl">child:</span> <span class="n">Builder</span><span class="p">(</span><span class="nl">builder:</span> <span class="p">(</span><span class="n">context</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">RaisedButton</span><span class="p">(</span>
        <span class="nl">onPressed:</span> <span class="p">()</span> <span class="p">{</span>
          <span class="c1">// 查找父级最近的Scaffold对应的ScaffoldState对象</span>
          <span class="n">ScaffoldState</span> <span class="n">_state</span> <span class="o">=</span> <span class="n">context</span><span class="p">.</span><span class="n">findAncestorStateOfType</span><span class="o">&lt;</span><span class="n">ScaffoldState</span><span class="o">&gt;</span><span class="p">();</span>
          <span class="c1">//调用ScaffoldState的showSnackBar来弹出SnackBar</span>
          <span class="n">_state</span><span class="p">.</span><span class="n">showSnackBar</span><span class="p">(</span>
            <span class="n">SnackBar</span><span class="p">(</span>
              <span class="nl">content:</span> <span class="n">Text</span><span class="p">(</span><span class="s2">&quot;我是SnackBar&quot;</span><span class="p">),</span>
            <span class="p">),</span>
          <span class="p">);</span>
        <span class="p">},</span>
        <span class="nl">child:</span> <span class="n">Text</span><span class="p">(</span><span class="s2">&quot;显示SnackBar&quot;</span><span class="p">),</span>
      <span class="p">);</span>
    <span class="p">}),</span>
  <span class="p">),</span>
<span class="p">);</span>
</pre></div>
</div>
<p>上面示例运行后，点击”显示SnackBar“，效果如图3-1-2所示：</p>
<p><img alt="图3-1-2" src="../_images/3-1-2.png" /></p>
<p>一般来说，如果StatefulWidget的状态是私有的（不应该向外部暴露），那么我们代码中就不应该去直接获取其State对象；如果StatefulWidget的状态是希望暴露出的（通常还有一些组件的操作方法），我们则可以去直接获取其State对象。但是通过<code class="docutils literal notranslate"><span class="pre">context.findAncestorStateOfType</span></code>获取StatefulWidget的状态的方法是通用的，我们并不能在语法层面指定StatefulWidget的状态是否私有，所以在Flutter开发中便有了一个默认的约定：如果StatefulWidget的状态是希望暴露出的，应当在StatefulWidget中提供一个<code class="docutils literal notranslate"><span class="pre">of</span></code>静态方法来获取其State对象，开发者便可直接通过该方法来获取；如果State不希望暴露，则不提供<code class="docutils literal notranslate"><span class="pre">of</span></code>方法。这个约定在Flutter SDK里随处可见。所以，上面示例中的<code class="docutils literal notranslate"><span class="pre">Scaffold</span></code>也提供了一个<code class="docutils literal notranslate"><span class="pre">of</span></code>方法，我们其实是可以直接调用它的：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="p">...</span><span class="c1">//省略无关代码</span>
<span class="c1">// 直接通过of静态方法来获取ScaffoldState </span>
<span class="n">ScaffoldState</span> <span class="n">_state</span><span class="o">=</span><span class="n">Scaffold</span><span class="p">.</span><span class="n">of</span><span class="p">(</span><span class="n">context</span><span class="p">);</span> 
<span class="n">_state</span><span class="p">.</span><span class="n">showSnackBar</span><span class="p">(</span>
  <span class="n">SnackBar</span><span class="p">(</span>
    <span class="nl">content:</span> <span class="n">Text</span><span class="p">(</span><span class="s2">&quot;我是SnackBar&quot;</span><span class="p">),</span>
  <span class="p">),</span>
<span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="globalkey">
<h3>通过GlobalKey<a class="headerlink" href="#globalkey" title="Permalink to this headline">¶</a></h3>
<p>Flutter还有一种通用的获取<code class="docutils literal notranslate"><span class="pre">State</span></code>对象的方法——通过GlobalKey来获取！ 步骤分两步：</p>
<ol>
<li><p>给目标<code class="docutils literal notranslate"><span class="pre">StatefulWidget</span></code>添加<code class="docutils literal notranslate"><span class="pre">GlobalKey</span></code>。</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="c1">//定义一个globalKey, 由于GlobalKey要保持全局唯一性，我们使用静态变量存储</span>
<span class="kd">static</span> <span class="n">GlobalKey</span><span class="o">&lt;</span><span class="n">ScaffoldState</span><span class="o">&gt;</span> <span class="n">_globalKey</span><span class="o">=</span> <span class="n">GlobalKey</span><span class="p">();</span>
<span class="p">...</span>
<span class="n">Scaffold</span><span class="p">(</span>
    <span class="nl">key:</span> <span class="n">_globalKey</span> <span class="p">,</span> <span class="c1">//设置key</span>
    <span class="p">...</span>  
<span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>通过<code class="docutils literal notranslate"><span class="pre">GlobalKey</span></code>来获取<code class="docutils literal notranslate"><span class="pre">State</span></code>对象</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="n">_globalKey</span><span class="p">.</span><span class="n">currentState</span><span class="p">.</span><span class="n">openDrawer</span><span class="p">()</span>
</pre></div>
</div>
</li>
</ol>
<p>GlobalKey是Flutter提供的一种在整个APP中引用element的机制。如果一个widget设置了<code class="docutils literal notranslate"><span class="pre">GlobalKey</span></code>，那么我们便可以通过<code class="docutils literal notranslate"><span class="pre">globalKey.currentWidget</span></code>获得该widget对象、<code class="docutils literal notranslate"><span class="pre">globalKey.currentElement</span></code>来获得widget对应的element对象，如果当前widget是<code class="docutils literal notranslate"><span class="pre">StatefulWidget</span></code>，则可以通过<code class="docutils literal notranslate"><span class="pre">globalKey.currentState</span></code>来获得该widget对应的state对象。</p>
<blockquote>
<div><p>注意：使用GlobalKey开销较大，如果有其他可选方案，应尽量避免使用它。另外同一个GlobalKey在整个widget树中必须是唯一的，不能重复。</p>
</div></blockquote>
</div>
</div>
<div class="section" id="flutter-sdk">
<h2>3.1.8 Flutter SDK内置组件库介绍<a class="headerlink" href="#flutter-sdk" title="Permalink to this headline">¶</a></h2>
<p>Flutter提供了一套丰富、强大的基础组件，在基础组件库之上Flutter又提供了一套Material风格（Android默认的视觉风格）和一套Cupertino风格（iOS视觉风格）的组件库。要使用基础组件库，需要先导入：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="s1">&#39;package:flutter/widgets.dart&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>下面我们介绍一下常用的组件。</p>
<div class="section" id="id5">
<h3>基础组件<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://docs.flutter.io/flutter/widgets/Text-class.html"><code class="docutils literal notranslate"><span class="pre">Text</span></code></a>：该组件可让您创建一个带格式的文本。</p></li>
<li><p><a class="reference external" href="https://docs.flutter.io/flutter/widgets/Row-class.html"><code class="docutils literal notranslate"><span class="pre">Row</span></code></a>、 <a class="reference external" href="https://docs.flutter.io/flutter/widgets/Column-class.html"><code class="docutils literal notranslate"><span class="pre">Column</span></code></a>： 这些具有弹性空间的布局类Widget可让您在水平（Row）和垂直（Column）方向上创建灵活的布局。其设计是基于Web开发中的Flexbox布局模型。</p></li>
<li><p><a class="reference external" href="https://docs.flutter.io/flutter/widgets/Stack-class.html"><code class="docutils literal notranslate"><span class="pre">Stack</span></code></a>： 取代线性布局 (译者语：和Android中的<code class="docutils literal notranslate"><span class="pre">FrameLayout</span></code>相似)，<a class="reference external" href="https://docs.flutter.io/flutter/widgets/Stack-class.html"><code class="docutils literal notranslate"><span class="pre">Stack</span></code></a>允许子 widget 堆叠， 你可以使用 <a class="reference external" href="https://docs.flutter.io/flutter/widgets/Positioned-class.html"><code class="docutils literal notranslate"><span class="pre">Positioned</span></code></a> 来定位他们相对于<code class="docutils literal notranslate"><span class="pre">Stack</span></code>的上下左右四条边的位置。Stacks是基于Web开发中的绝对定位（absolute positioning )布局模型设计的。</p></li>
<li><p><a class="reference external" href="https://docs.flutter.io/flutter/widgets/Container-class.html"><code class="docutils literal notranslate"><span class="pre">Container</span></code></a>： <a class="reference external" href="https://docs.flutter.io/flutter/widgets/Container-class.html"><code class="docutils literal notranslate"><span class="pre">Container</span></code></a> 可让您创建矩形视觉元素。container 可以装饰一个<a class="reference external" href="https://docs.flutter.io/flutter/painting/BoxDecoration-class.html"><code class="docutils literal notranslate"><span class="pre">BoxDecoration</span></code></a>, 如 background、一个边框、或者一个阴影。 <a class="reference external" href="https://docs.flutter.io/flutter/widgets/Container-class.html"><code class="docutils literal notranslate"><span class="pre">Container</span></code></a> 也可以具有边距（margins）、填充(padding)和应用于其大小的约束(constraints)。另外， <a class="reference external" href="https://docs.flutter.io/flutter/widgets/Container-class.html"><code class="docutils literal notranslate"><span class="pre">Container</span></code></a>可以使用矩阵在三维空间中对其进行变换。</p></li>
</ul>
</div>
<div class="section" id="material">
<h3>Material组件<a class="headerlink" href="#material" title="Permalink to this headline">¶</a></h3>
<p>Flutter提供了一套丰富的Material组件，它可以帮助我们构建遵循Material Design设计规范的应用程序。Material应用程序以<a class="reference external" href="https://docs.flutter.io/flutter/material/MaterialApp-class.html"><code class="docutils literal notranslate"><span class="pre">MaterialApp</span></code></a> 组件开始， 该组件在应用程序的根部创建了一些必要的组件，比如<code class="docutils literal notranslate"><span class="pre">Theme</span></code>组件，它用于配置应用的主题。 是否使用<a class="reference external" href="https://docs.flutter.io/flutter/material/MaterialApp-class.html"><code class="docutils literal notranslate"><span class="pre">MaterialApp</span></code></a>完全是可选的，但是使用它是一个很好的做法。在之前的示例中，我们已经使用过多个Material 组件了，如：<code class="docutils literal notranslate"><span class="pre">Scaffold</span></code>、<code class="docutils literal notranslate"><span class="pre">AppBar</span></code>、<code class="docutils literal notranslate"><span class="pre">FlatButton</span></code>等。要使用Material 组件，需要先引入它：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="s1">&#39;package:flutter/material.dart&#39;</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="cupertino">
<h3>Cupertino组件<a class="headerlink" href="#cupertino" title="Permalink to this headline">¶</a></h3>
<p>Flutter也提供了一套丰富的Cupertino风格的组件，尽管目前还没有Material 组件那么丰富，但是它仍在不断的完善中。值得一提的是在Material 组件库中有一些组件可以根据实际运行平台来切换表现风格，比如<code class="docutils literal notranslate"><span class="pre">MaterialPageRoute</span></code>，在路由切换时，如果是Android系统，它将会使用Android系统默认的页面切换动画(从底向上)；如果是iOS系统，它会使用iOS系统默认的页面切换动画（从右向左）。由于在前面的示例中还没有Cupertino组件的示例，下面我们实现一个简单的Cupertino组件风格的页面：</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span>//导入cupertino widget库
import &#39;package:flutter/cupertino.dart&#39;;

class CupertinoTestRoute extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return CupertinoPageScaffold(
      navigationBar: CupertinoNavigationBar(
        middle: Text(&quot;Cupertino Demo&quot;),
      ),
      child: Center(
        child: CupertinoButton(
            color: CupertinoColors.activeBlue,
            child: Text(&quot;Press&quot;),
            onPressed: () {}
        ),
      ),
    );
  }
}
</pre></div>
</div>
<p>下面（图3-3）是在iPhoneX上页面效果截图：</p>
<p><img alt="图3-3" src="../_images/3-3.png" /></p>
</div>
<div class="section" id="id6">
<h3>关于示例<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>本章后面章节的示例中会使用一些布局类组件，如<code class="docutils literal notranslate"><span class="pre">Scaffold</span></code>、<code class="docutils literal notranslate"><span class="pre">Row</span></code>、<code class="docutils literal notranslate"><span class="pre">Column</span></code>等，这些组件将在后面“布局类组件”一章中详细介绍，读者可以先不用关注。</p>
</div>
<div class="section" id="id7">
<h3>总结<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>Flutter提供了丰富的组件，在实际的开发中你可以根据需要随意使用它们，而不必担心引入过多组件库会让你的应用安装包变大，这不是web开发，dart在编译时只会编译你使用了的代码。由于Material和Cupertino都是在基础组件库之上的，所以如果我们的应用中引入了这两者之一，则不需要再引入<code class="docutils literal notranslate"><span class="pre">flutter/widgets.dart</span></code>了，因为它们内部已经引入过了。</p>
</div>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">flutter in action</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, mahongquan.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.5.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/chapter3/flutter_widget_intro.md.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>